From bd8b08bb67cc88324011c683cf9abc194a4d095b Mon Sep 17 00:00:00 2001
From: Ban Feng <kcfeng0@nuvoton.com>
Date: Tue, 13 Jun 2023 11:24:46 +0800
Subject: [PATCH 2/2] Implements Power{Equipment, Distribution, Supply,
 SupplyMetrics} schema

Signed-off-by: Ban Feng <kcfeng0@nuvoton.com>
---
 redfish-core/include/redfish.hpp          |   6 +
 redfish-core/lib/power_distribution.hpp   | 338 ++++++++++++++++++++++
 redfish-core/lib/power_equipment.hpp      |  47 +++
 redfish-core/lib/power_supply.hpp         | 198 +++++++++++--
 redfish-core/lib/power_supply_metrics.hpp | 232 +++++++++++++++
 redfish-core/lib/service_root.hpp         |   2 +
 6 files changed, 800 insertions(+), 23 deletions(-)
 create mode 100644 redfish-core/lib/power_distribution.hpp
 create mode 100644 redfish-core/lib/power_equipment.hpp
 create mode 100644 redfish-core/lib/power_supply_metrics.hpp

Index: git/redfish-core/include/redfish.hpp
===================================================================
--- git.orig/redfish-core/include/redfish.hpp
+++ git/redfish-core/include/redfish.hpp
@@ -38,8 +38,11 @@
 #include "pcie.hpp"
 #include "pcie_slots.hpp"
 #include "power.hpp"
+#include "power_distribution.hpp"
+#include "power_equipment.hpp"
 #include "power_subsystem.hpp"
 #include "power_supply.hpp"
+#include "power_supply_metrics.hpp"
 #include "processor.hpp"
 #include "redfish_sessions.hpp"
 #include "redfish_v1.hpp"
@@ -91,9 +94,12 @@ class RedfishService
 #endif
 #ifdef BMCWEB_NEW_POWERSUBSYSTEM_THERMALSUBSYSTEM
         requestRoutesEnvironmentMetrics(app);
+        requestRoutesPowerDistributionCollection(app);
+        requestRoutesPowerEquipment(app);
         requestRoutesPowerSubsystem(app);
         requestRoutesPowerSupply(app);
         requestRoutesPowerSupplyCollection(app);
+        requestRoutesPowerSupplyMetricsCollection(app);
         requestRoutesThermalSubsystem(app);
 #endif
         requestRoutesManagerCollection(app);
Index: git/redfish-core/lib/power_distribution.hpp
===================================================================
--- /dev/null
+++ git/redfish-core/lib/power_distribution.hpp
@@ -0,0 +1,338 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+#include "utils/chassis_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <boost/url/format.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+#include <array>
+#include <string_view>
+
+namespace redfish
+{
+
+inline void handlePowerDistributionCollectionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment/PowerShelves";
+    asyncResp->res.jsonValue["Name"] = "PowerEquipment PowerShelves Collection";
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    collection_util::getCollectionMembers(
+        asyncResp, boost::urls::url("/redfish/v1/PowerEquipment/PowerShelves"), interfaces);
+}
+
+inline void doPowerDistributionCollection(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId,
+    const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["Name"] = "Power Shelf Configuration";
+    asyncResp->res.jsonValue["Id"] = "PowerShelf";
+    asyncResp->res.jsonValue["Description"] = "Power Shelf Configuration Service";
+    asyncResp->res.jsonValue["EquipmentTye"] = "PowerShelf";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}", powerdistributionId);
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+    asyncResp->res.jsonValue["PowerSupplies"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies",
+                            powerdistributionId);
+    asyncResp->res.jsonValue["Metrics"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics",
+                            powerdistributionId);
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    dbus::utility::getSubTree(
+        "/xyz/openbmc_project/inventory", 0, interfaces,
+        [asyncResp, powerdistributionId(std::string(powerdistributionId))](
+            const boost::system::error_code& ec,
+            const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        // Iterate over all retrieved ObjectPaths.
+        for (const std::pair<
+                 std::string,
+                 std::vector<std::pair<std::string, std::vector<std::string>>>>&
+                 object : subtree)
+        {
+            const std::string& path = object.first;
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object.second;
+
+            sdbusplus::message::object_path objPath(path);
+            if (objPath.filename() != powerdistributionId)
+            {
+                continue;
+            }
+
+            if (connectionNames.empty())
+            {
+                BMCWEB_LOG_ERROR << "Got 0 Connection names";
+                continue;
+            }
+
+            const std::string& connectionName = connectionNames[0].first;
+
+            sdbusplus::asio::getAllProperties(
+                *crow::connections::systemBus, connectionName, path,
+                "xyz.openbmc_project.Inventory.Decorator.Asset",
+                [asyncResp, powerdistributionId(std::string(powerdistributionId))](
+                    const boost::system::error_code& /*ec2*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+                const std::string* partNumber = nullptr;
+                const std::string* serialNumber = nullptr;
+                const std::string* manufacturer = nullptr;
+                const std::string* model = nullptr;
+                const std::string* sparePartNumber = nullptr;
+
+                const bool success = sdbusplus::unpackPropertiesNoThrow(
+                    dbus_utils::UnpackErrorPrinter(), propertiesList,
+                    "PartNumber", partNumber, "SerialNumber", serialNumber,
+                    "Manufacturer", manufacturer, "Model", model,
+                    "SparePartNumber", sparePartNumber);
+
+                if (!success)
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                if (partNumber != nullptr)
+                {
+                    asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+                }
+
+                if (serialNumber != nullptr)
+                {
+                    asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+                }
+
+                if (manufacturer != nullptr)
+                {
+                    asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+                }
+
+                if (model != nullptr)
+                {
+                    asyncResp->res.jsonValue["Model"] = *model;
+                }
+
+                // SparePartNumber is optional on D-Bus
+                // so skip if it is empty
+                if (sparePartNumber != nullptr && !sparePartNumber->empty())
+                {
+                    asyncResp->res.jsonValue["SparePartNumber"] =
+                        *sparePartNumber;
+                }
+                });
+
+            return;
+        }
+        });
+}
+
+inline void handlePowerDistributionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionCollection, asyncResp, powerdistributionId));
+}
+
+inline void
+    getTemperatureReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& chassisId,
+                          const std::string& sensorPath,
+                          const std::string& id,
+                          const std::string& location)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        sensorPath, interfaces,
+        [asyncResp, chassisId, sensorPath, id, location]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, sensorPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error for DeratingFactor";
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value)
+            {
+                nlohmann::json::object_t item;
+                item["DataSourceUri"] = boost::urls::format(
+                    "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                item["Reading"] = std::to_string(value);
+
+                nlohmann::json& sensorList = asyncResp->res.jsonValue[location];
+                sensorList.emplace_back(std::move(item));
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerDistributionMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                       const std::string& powerdistributionId,
+                                       const std::string& sensorPath)
+{
+    sdbusplus::message::object_path path(sensorPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty() || sensorName.find("Temp") == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("BUV") != std::string::npos)
+    {
+        getTemperatureReading(asyncResp, powerdistributionId, sensorPath,
+                              id, "TemperatureCelsius");
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerDistributionMetricsCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& powerdistributionId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistributionMetrics.v1_2_0.PowerDistributionMetrics";
+    asyncResp->res.jsonValue["Name"] = "Summary Metrics";
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics", powerdistributionId);
+
+    asyncResp->res.jsonValue["TemperatureCelsius"] = nlohmann::json::array();
+
+    std::string sensorPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        sensorPath, [asyncResp, powerdistributionId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error" << ec.value();
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerDistributionMetricsList(asyncResp, powerdistributionId, endpoint);
+            }
+        });
+}
+
+inline void handlePowerDistributionMetricsGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionMetricsCollection, asyncResp, powerdistributionId));
+}
+
+/**
+ *  PowerDistributionCollection derived class for delivering PowerDistribution
+ *  Collection Schema Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerDistributionCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerDistributionMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionMetricsGet, std::ref(app)));
+}
+
+} // namespace redfish
Index: git/redfish-core/lib/power_equipment.hpp
===================================================================
--- /dev/null
+++ git/redfish-core/lib/power_equipment.hpp
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+namespace redfish
+{
+
+inline void handlePowerEquipmentGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerEquipment.v1_1_0.PowerEquipment";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment";
+    asyncResp->res.jsonValue["Name"] = "Power Equipment Configuration";
+    asyncResp->res.jsonValue["Id"] = "Power Equipment";
+    asyncResp->res.jsonValue["Description"] = "Power Equipment Configuration Service";
+    asyncResp->res.jsonValue["PowerShelves"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment/PowerShelves";
+}
+
+/**
+ * ChassisCollection derived class for delivering Chassis Collection Schema
+ *  Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerEquipment(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/")
+        .privileges(redfish::privileges::getPowerEquipment)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerEquipmentGet, std::ref(app)));
+}
+
+} // namespace redfish
Index: git/redfish-core/lib/power_supply.hpp
===================================================================
--- git.orig/redfish-core/lib/power_supply.hpp
+++ git/redfish-core/lib/power_supply.hpp
@@ -20,7 +20,8 @@ namespace redfish
 {
 
 inline void
-    updatePowerSupplyList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    updatePowerSupplyList(const crow::Request& req,
+                          const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                           const std::string& chassisId,
                           const std::string& powerSupplyPath)
 {
@@ -31,10 +32,21 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     nlohmann::json item = nlohmann::json::object();
-    item["@odata.id"] = boost::urls::format(
-        "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-        powerSupplyName);
+    if (found == std::string::npos)
+    {
+        item["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+            powerSupplyName);
+    }
+    else
+    {
+        item["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+            powerSupplyName);
+    }
 
     nlohmann::json& powerSupplyList = asyncResp->res.jsonValue["Members"];
     powerSupplyList.emplace_back(std::move(item));
@@ -42,7 +54,8 @@ inline void
 }
 
 inline void
-    doPowerSupplyCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyCollection(const crow::Request& req,
+                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                             const std::string& chassisId,
                             const std::optional<std::string>& validChassisPath)
 {
@@ -52,14 +65,26 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     asyncResp->res.addHeader(
         boost::beast::http::field::link,
         "</redfish/v1/JsonSchemas/PowerSupplyCollection/PowerSupplyCollection.json>; rel=describedby");
     asyncResp->res.jsonValue["@odata.type"] =
         "#PowerSupplyCollection.PowerSupplyCollection";
     asyncResp->res.jsonValue["Name"] = "Power Supply Collection";
-    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-        "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] =
+            boost::urls::format("/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] =
+            boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies", chassisId);
+    }
+
     asyncResp->res.jsonValue["Description"] =
         "The collection of PowerSupply resource instances.";
     asyncResp->res.jsonValue["Members"] = nlohmann::json::array();
@@ -67,7 +92,7 @@ inline void
 
     std::string powerPath = *validChassisPath + "/powered_by";
     dbus::utility::getAssociationEndPoints(
-        powerPath, [asyncResp, chassisId](
+        powerPath, [req, asyncResp, chassisId](
                        const boost::system::error_code& ec,
                        const dbus::utility::MapperEndPoints& endpoints) {
             if (ec)
@@ -82,7 +107,7 @@ inline void
 
             for (const auto& endpoint : endpoints)
             {
-                updatePowerSupplyList(asyncResp, chassisId, endpoint);
+                updatePowerSupplyList(req, asyncResp, chassisId, endpoint);
             }
         });
 }
@@ -124,7 +149,7 @@ inline void handlePowerSupplyCollectionG
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyCollection, asyncResp, chassisId));
+        std::bind_front(doPowerSupplyCollection, req, asyncResp, chassisId));
 }
 
 inline void requestRoutesPowerSupplyCollection(App& app)
@@ -138,6 +163,11 @@ inline void requestRoutesPowerSupplyColl
         .privileges(redfish::privileges::getPowerSupplyCollection)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/")
+        .privileges(redfish::privileges::getPowerSupplyCollection)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
 }
 
 inline bool checkPowerSupplyId(const std::string& powerSupplyPath,
@@ -308,16 +338,46 @@ inline void
 }
 
 inline void
-    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+    getPowerSupplyHotPluggable(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                               const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getProperty<bool>(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Replaceable", "HotPluggable",
+        [asyncResp](const boost::system::error_code& ec, const bool value) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR << "DBUS response error for State";
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+        if (!value)
+        {
+            asyncResp->res.jsonValue["HotPluggable"] = "False";
+        }
+        else
+        {
+            asyncResp->res.jsonValue["HotPluggable"] = "True";
+        }
+        });
+}
+
+inline void
+    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& powerSupplyPath)
 {
     static const std::string efficiencyIntf =
-        "xyz.openbmc_project.Control.PowerSupplyAttributes";
+        //"xyz.openbmc_project.Control.PowerSupplyAttributes";
+        "xyz.openbmc_project.Inventory.Decorator.EfficiencyRatings";
     // Gets the Power Supply Attributes such as EfficiencyPercent.
     // Currently we only support one power supply EfficiencyPercent, use this
     // for all the power supplies.
     crow::connections::systemBus->async_method_call(
-        [asyncResp](const boost::system::error_code ec,
-                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        [asyncResp, powerSupplyPath](const boost::system::error_code ec,
+            const dbus::utility::MapperGetSubTreeResponse& subtree) {
         if (ec)
         {
             if (ec.value() == EBADR)
@@ -333,7 +393,7 @@ inline void
         {
             for (const auto& [service, interfaces] : serviceMap)
             {
-                sdbusplus::asio::getProperty<uint32_t>(
+                /*sdbusplus::asio::getProperty<uint32_t>(
                     *crow::connections::systemBus, service, path,
                     efficiencyIntf, "DeratingFactor",
                     [asyncResp](const boost::system::error_code ec1,
@@ -344,10 +404,73 @@ inline void
                     }
 
                     nlohmann::json item;
-                    item["EfficiencyPercent"] = value;
+                    item["EfficiencyPercent"] = std::to_string(value);
+                    item["LoadPercent"] = "30";
                     nlohmann::json& efficiencyList =
                         asyncResp->res.jsonValue["EfficiencyRatings"];
                     efficiencyList.emplace_back(std::move(item));
+                    });*/
+                if (powerSupplyPath != path)
+                {
+                    continue;
+                }
+
+                sdbusplus::asio::getAllProperties(
+                    *crow::connections::systemBus, service, path,
+                    efficiencyIntf,
+                    [asyncResp](const boost::system::error_code ec2,
+                                const dbus::utility::DBusPropertiesMap& propertiesList) {
+                    if (ec2)
+                    {
+                        if (ec2.value() != EBADR)
+                        {
+                            messages::internalError(asyncResp->res);
+                        }
+                        return;
+                    }
+
+                    const double* effiPH = nullptr;
+                    const double* effiPM = nullptr;
+                    const double* effiPL = nullptr;
+                    const double* loadPH = nullptr;
+                    const double* loadPM = nullptr;
+                    const double* loadPL = nullptr;
+
+                    const bool success = sdbusplus::unpackPropertiesNoThrow(
+                        dbus_utils::UnpackErrorPrinter(), propertiesList, "EfficiencyPercentHigh",
+                        effiPH, "EfficiencyPercentMedium", effiPM, "EfficiencyPercentLow",
+                        effiPL, "LoadPercentHigh", loadPH, "LoadPercentMedium", loadPM,
+                        "LoadPercentLow", loadPL);
+
+                    if (!success)
+                    {
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    nlohmann::json item;
+                    nlohmann::json& efficiencyList =
+                        asyncResp->res.jsonValue["EfficiencyRatings"];
+                    if (effiPH != nullptr && loadPH != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPH;
+                        item["LoadPercent"] = *loadPH;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPM != nullptr && loadPM != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPM;
+                        item["LoadPercent"] = *loadPM;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPL != nullptr && loadPL != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPL;
+                        item["LoadPercent"] = *loadPL;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
                     });
             }
         }
@@ -360,7 +483,8 @@ inline void
 }
 
 inline void
-    doPowerSupplyGet(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                      const std::string& chassisId,
                      const std::string& powerSupplyId,
                      const std::optional<std::string>& validChassisPath)
@@ -371,9 +495,11 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     // Get the correct Path and Service that match the input parameters
     getValidPowerSupplyPath(asyncResp, *validChassisPath, powerSupplyId,
-                            [asyncResp, chassisId, powerSupplyId](
+                            [asyncResp, chassisId, powerSupplyId, found](
                                 const std::string& powerSupplyPath) {
         asyncResp->res.addHeader(
             boost::beast::http::field::link,
@@ -382,9 +508,25 @@ inline void
             "#PowerSupply.v1_5_0.PowerSupply";
         asyncResp->res.jsonValue["Name"] = "Power Supply";
         asyncResp->res.jsonValue["Id"] = powerSupplyId;
-        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-            powerSupplyId);
+
+        if (found == std::string::npos)
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] =
+                boost::urls::format("/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+                                    chassisId, powerSupplyId);
+        }
+        else
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] =
+                boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+                chassisId, powerSupplyId);
+        }
 
         asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
         asyncResp->res.jsonValue["Status"]["Health"] = "OK";
@@ -406,9 +548,11 @@ inline void
                                  powerSupplyPath);
             getPowerSupplyAsset(asyncResp, object.begin()->first,
                                 powerSupplyPath);
+            getPowerSupplyHotPluggable(asyncResp, object.begin()->first,
+                                       powerSupplyPath);
             });
 
-        getEfficiencyPercent(asyncResp);
+        getEfficiencyPercent(asyncResp, powerSupplyPath);
     });
 }
 
@@ -456,7 +600,7 @@ inline void
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyGet, asyncResp, chassisId, powerSupplyId));
+        std::bind_front(doPowerSupplyGet, req, asyncResp, chassisId, powerSupplyId));
 }
 
 inline void requestRoutesPowerSupply(App& app)
@@ -472,6 +616,12 @@ inline void requestRoutesPowerSupply(App
         .privileges(redfish::privileges::getPowerSupply)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyGet, std::ref(app)));
+
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/")
+        .privileges(redfish::privileges::getPowerSupply)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyGet, std::ref(app)));
 }
 
 } // namespace redfish
Index: git/redfish-core/lib/power_supply_metrics.hpp
===================================================================
--- /dev/null
+++ git/redfish-core/lib/power_supply_metrics.hpp
@@ -0,0 +1,232 @@
+#pragma once
+
+#include "app.hpp"
+#include "dbus_utility.hpp"
+#include "query.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/chassis_utils.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/url/format.hpp>
+
+#include <memory>
+#include <optional>
+#include <string>
+
+namespace redfish
+{
+
+inline void
+    getPowerSupplyReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& chassisId,
+                          const std::string& powerSupplyPath,
+                          const std::string& id,
+                          const std::string& location)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        powerSupplyPath, interfaces,
+        [asyncResp, chassisId, powerSupplyPath, id, location]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, powerSupplyPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error for DeratingFactor";
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value)
+            {
+                nlohmann::json::object_t item;
+                item["DataSourceUri"] = boost::urls::format(
+                    "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                item["Reading"] = std::to_string(value);
+
+                nlohmann::json& sensorList = asyncResp->res.jsonValue[location];
+                sensorList.emplace_back(std::move(item));
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerSupplyMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                 const std::string& chassisId,
+                                 const std::string& powerSupplyId,
+                                 const std::string& powerSupplyPath)
+{
+    sdbusplus::message::object_path path(powerSupplyPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty())
+    {
+        return;
+    }
+
+    const std::string& psuId =
+        boost::replace_all_copy(powerSupplyId, "powersupply", "PSU");
+
+    if (sensorName.find(psuId) == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("Input_Current") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputCurrentAmps");
+    }
+    else if (sensorName.find("Input_Power") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputPowerWatts");
+    }
+    else if (sensorName.find("Input_Voltage") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputVoltage");
+    }
+    else if (sensorName.find("Output_Current") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailCurrentAmps");
+    }
+    else if (sensorName.find("Output_Power") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailPowerWatts");
+    }
+    else if (sensorName.find("Output_Voltage") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailVoltage");
+    }
+    else if (sensorName.find("Temperature") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "TemperatureCelsius");
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerSupplyMetricsGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& chassisId,
+                     const std::string& powerSupplyId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", chassisId);
+        return;
+    }
+
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerSupplyMetrics.v1_0_0.PowerSupplyMetrics";
+    asyncResp->res.jsonValue["Name"] = powerSupplyId;
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+
+    asyncResp->res.jsonValue["InputCurrentAmps"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["InputPowerWatts"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["InputVoltage"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["RailCurrentAmps"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["RailPowerWatts"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["RailVoltage"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["TemperatureCelsius"] = nlohmann::json::array();
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+
+    std::string powerPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        powerPath, [asyncResp, chassisId, powerSupplyId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error" << ec.value();
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerSupplyMetricsList(asyncResp, chassisId, powerSupplyId, endpoint);
+            }
+        });
+}
+
+inline void
+    handlePowerSupplyMetricsCollectionGet(App& app, const crow::Request& req,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& chassisId,
+                         const std::string& powerSupplyId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, chassisId,
+        std::bind_front(doPowerSupplyMetricsGet, req, asyncResp, chassisId, powerSupplyId));
+}
+
+inline void requestRoutesPowerSupplyMetricsCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/PowerSubsystem/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+}
+
+} // namespace redfish
Index: git/redfish-core/lib/service_root.hpp
===================================================================
--- git.orig/redfish-core/lib/service_root.hpp
+++ git/redfish-core/lib/service_root.hpp
@@ -82,6 +82,8 @@ inline void handleServiceRootGetImpl(
     asyncResp->res.jsonValue["TelemetryService"]["@odata.id"] =
         "/redfish/v1/TelemetryService";
     asyncResp->res.jsonValue["Cables"]["@odata.id"] = "/redfish/v1/Cables";
+    asyncResp->res.jsonValue["PowerEquipment"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment";
 
     asyncResp->res.jsonValue["Links"]["ManagerProvidingService"]["@odata.id"] =
         "/redfish/v1/Managers/bmc";

From 4848435c42704ff732ed3588c7031838253d660b Mon Sep 17 00:00:00 2001
From: Ban Feng <kcfeng0@nuvoton.com>
Date: Wed, 7 Jun 2023 09:47:57 +0800
Subject: [PATCH 1/2] Implements PowerSubsystem schema

This patch cherry-pick the following commits:
https://gerrit.openbmc.org/c/openbmc/bmcweb/+/57669
https://gerrit.openbmc.org/c/openbmc/bmcweb/+/57670
https://gerrit.openbmc.org/c/openbmc/bmcweb/+/57671
https://gerrit.openbmc.org/c/openbmc/bmcweb/+/57709

Signed-off-by: Allen Kang <jhkang@nuvoton.com>
Signed-off-by: Ban Feng <kcfeng0@nuvoton.com>
---
 Redfish.md                        |   8 ++
 redfish-core/lib/power_supply.hpp | 209 ++++++++++++++++++++++++++++--
 2 files changed, 209 insertions(+), 8 deletions(-)

diff --git a/Redfish.md b/Redfish.md
index c416a5476..c805fa828 100644
--- a/Redfish.md
+++ b/Redfish.md
@@ -379,6 +379,14 @@ Fields common to all schemas
 
 ##### PowerSupply
 
+- EfficiencyPercent
+- Manufacturer
+- Model
+- PartNumber
+- SerialNumber
+- SparePartNumber
+- Status
+
 ### /redfish/v1/EventService/
 
 #### EventService
diff --git a/redfish-core/lib/power_supply.hpp b/redfish-core/lib/power_supply.hpp
index ebc61c50a..593505190 100644
--- a/redfish-core/lib/power_supply.hpp
+++ b/redfish-core/lib/power_supply.hpp
@@ -5,6 +5,10 @@
 #include "query.hpp"
 #include "registries/privilege_registry.hpp"
 #include "utils/chassis_utils.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/url/format.hpp>
 
 #include <boost/url/format.hpp>
 
@@ -145,11 +149,10 @@ inline bool checkPowerSupplyId(const std::string& powerSupplyPath,
     return !(powerSupplyName.empty() || powerSupplyName != powerSupplyId);
 }
 
-inline void
-    getValidPowerSupplyPath(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-                            const std::string& validChassisPath,
-                            const std::string& powerSupplyId,
-                            std::function<void()>&& callback)
+inline void getValidPowerSupplyPath(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& validChassisPath, const std::string& powerSupplyId,
+    std::function<void(const std::string& powerSupplyPath)>&& callback)
 {
     std::string powerPath = validChassisPath + "/powered_by";
     dbus::utility::getAssociationEndPoints(
@@ -175,7 +178,7 @@ inline void
             {
                 if (checkPowerSupplyId(endpoint, powerSupplyId))
                 {
-                    callback();
+                    callback(endpoint);
                     return;
                 }
             }
@@ -191,6 +194,171 @@ inline void
         });
 }
 
+inline void
+    getPowerSupplyState(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                        const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getProperty<bool>(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Item", "Present",
+        [asyncResp](const boost::system::error_code& ec, const bool value) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR << "DBUS response error for State";
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+
+        if (!value)
+        {
+            asyncResp->res.jsonValue["Status"]["State"] = "Absent";
+        }
+        });
+}
+
+inline void
+    getPowerSupplyHealth(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getProperty<bool>(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.State.Decorator.OperationalStatus", "Functional",
+        [asyncResp](const boost::system::error_code& ec, const bool value) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR << "DBUS response error for Health";
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+
+        if (!value)
+        {
+            asyncResp->res.jsonValue["Status"]["Health"] = "Critical";
+        }
+        });
+}
+
+inline void
+    getPowerSupplyAsset(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                        const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Asset",
+        [asyncResp](const boost::system::error_code ec,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+
+        const std::string* partNumber = nullptr;
+        const std::string* serialNumber = nullptr;
+        const std::string* manufacturer = nullptr;
+        const std::string* model = nullptr;
+        const std::string* sparePartNumber = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "PartNumber",
+            partNumber, "SerialNumber", serialNumber, "Manufacturer",
+            manufacturer, "Model", model, "SparePartNumber", sparePartNumber);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (partNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+        }
+
+        if (serialNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+        }
+
+        if (manufacturer != nullptr)
+        {
+            asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+        }
+
+        if (model != nullptr)
+        {
+            asyncResp->res.jsonValue["Model"] = *model;
+        }
+
+        // SparePartNumber is optional on D-Bus so skip if it is empty
+        if (sparePartNumber != nullptr && !sparePartNumber->empty())
+        {
+            asyncResp->res.jsonValue["SparePartNumber"] = *sparePartNumber;
+        }
+        });
+}
+
+inline void
+    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    static const std::string efficiencyIntf =
+        "xyz.openbmc_project.Control.PowerSupplyAttributes";
+    // Gets the Power Supply Attributes such as EfficiencyPercent.
+    // Currently we only support one power supply EfficiencyPercent, use this
+    // for all the power supplies.
+    crow::connections::systemBus->async_method_call(
+        [asyncResp](const boost::system::error_code ec,
+                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            if (ec.value() == EBADR)
+            {
+                return;
+            }
+            BMCWEB_LOG_ERROR << "respHandler DBus error " << ec.message();
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        for (const auto& [path, serviceMap] : subtree)
+        {
+            for (const auto& [service, interfaces] : serviceMap)
+            {
+                sdbusplus::asio::getProperty<uint32_t>(
+                    *crow::connections::systemBus, service, path,
+                    efficiencyIntf, "DeratingFactor",
+                    [asyncResp](const boost::system::error_code ec1,
+                                const uint32_t value) {
+                    if (ec1 || value == 0)
+                    {
+                        return;
+                    }
+
+                    nlohmann::json item;
+                    item["EfficiencyPercent"] = value;
+                    nlohmann::json& efficiencyList =
+                        asyncResp->res.jsonValue["EfficiencyRatings"];
+                    efficiencyList.emplace_back(std::move(item));
+                    });
+            }
+        }
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+        "/xyz/openbmc_project", 0,
+        std::array<const char*, 1>{efficiencyIntf.c_str()});
+}
+
 inline void
     doPowerSupplyGet(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                      const std::string& chassisId,
@@ -205,7 +373,8 @@ inline void
 
     // Get the correct Path and Service that match the input parameters
     getValidPowerSupplyPath(asyncResp, *validChassisPath, powerSupplyId,
-                            [asyncResp, chassisId, powerSupplyId]() {
+                            [asyncResp, chassisId, powerSupplyId](
+                                const std::string& powerSupplyPath) {
         asyncResp->res.addHeader(
             boost::beast::http::field::link,
             "</redfish/v1/JsonSchemas/PowerSupply/PowerSupply.json>; rel=describedby");
@@ -216,6 +385,30 @@ inline void
         asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
             "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
             powerSupplyId);
+
+        asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+        asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+
+        dbus::utility::getDbusObject(
+            powerSupplyPath, {},
+            [asyncResp,
+             powerSupplyPath](const boost::system::error_code& ec,
+                              const dbus::utility::MapperGetObject& object) {
+            if (ec || object.empty())
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            getPowerSupplyState(asyncResp, object.begin()->first,
+                                powerSupplyPath);
+            getPowerSupplyHealth(asyncResp, object.begin()->first,
+                                 powerSupplyPath);
+            getPowerSupplyAsset(asyncResp, object.begin()->first,
+                                powerSupplyPath);
+            });
+
+        getEfficiencyPercent(asyncResp);
     });
 }
 
@@ -242,7 +435,7 @@ inline void
 
         // Get the correct Path and Service that match the input parameters
         getValidPowerSupplyPath(asyncResp, *validChassisPath, powerSupplyId,
-                                [asyncResp]() {
+                                [asyncResp](const std::string&) {
             asyncResp->res.addHeader(
                 boost::beast::http::field::link,
                 "</redfish/v1/JsonSchemas/PowerSupply/PowerSupply.json>; rel=describedby");
-- 
2.34.1


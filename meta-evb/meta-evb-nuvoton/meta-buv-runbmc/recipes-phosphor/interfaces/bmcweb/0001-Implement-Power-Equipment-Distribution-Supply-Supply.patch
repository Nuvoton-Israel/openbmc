From cba2bd845d1c6f94370ed38b47ef32d0d02dc6d5 Mon Sep 17 00:00:00 2001
From: Eason Yang <yhyang2@nuvoton.com>
Date: Fri, 21 Jun 2024 14:13:05 +0800
Subject: [PATCH 1/1] Implement Power{Equipment, Distribution, Supply,
 SupplyMetrics} schema

Signed-off-by: Eason Yang <yhyang2@nuvoton.com>
Signed-off-by: Ban Feng <kcfeng0@nuvoton.com>
Signed-off-by: Allen Kang <jhkang@nuvoton.com>
---
 redfish-core/lib/power_distribution.hpp   | 576 ++++++++++++++++++++++
 redfish-core/lib/power_equipment.hpp      |  54 ++
 redfish-core/lib/power_supply.hpp         | 457 +++++++++++++----
 redfish-core/lib/power_supply_metrics.hpp | 261 ++++++++++
 redfish-core/lib/service_root.hpp         |   2 +
 redfish-core/src/redfish.cpp              |   6 +
 6 files changed, 1273 insertions(+), 83 deletions(-)
 create mode 100644 redfish-core/lib/power_distribution.hpp
 create mode 100644 redfish-core/lib/power_equipment.hpp
 create mode 100644 redfish-core/lib/power_supply_metrics.hpp

diff --git a/redfish-core/lib/power_distribution.hpp b/redfish-core/lib/power_distribution.hpp
new file mode 100644
index 0000000000..3f3c333b2a
--- /dev/null
+++ b/redfish-core/lib/power_distribution.hpp
@@ -0,0 +1,576 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/chassis_utils.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+#include "utils/sw_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <boost/url/format.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+#include <array>
+#include <string_view>
+
+namespace redfish
+{
+
+inline void handlePowerDistributionCollectionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment/PowerShelves";
+    asyncResp->res.jsonValue["Name"] = "PowerEquipment PowerShelves Collection";
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    collection_util::getCollectionMembers(
+        asyncResp, boost::urls::url("/redfish/v1/PowerEquipment/PowerShelves"),
+        interfaces, "/xyz/openbmc_project/inventory");
+}
+
+inline void getPowerDistributionProductionDate(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& model)
+{
+    constexpr std::array<std::string_view, 1> interfaces{
+        "xyz.openbmc_project.FruDevice"};
+    dbus::utility::getSubTree(
+        "/xyz/openbmc_project/FruDevice", 0, interfaces,
+        [asyncResp, model](
+            const boost::system::error_code& ec,
+            const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        // Iterate over all retrieved ObjectPaths.
+        for (const std::pair<
+                 std::string,
+                 std::vector<std::pair<std::string, std::vector<std::string>>>>&
+                 object : subtree)
+        {
+            const std::string& path = object.first;
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object.second;
+
+            sdbusplus::message::object_path objPath(path);
+            if (objPath.filename() != model)
+            {
+                continue;
+            }
+
+            if (connectionNames.empty())
+            {
+                BMCWEB_LOG_ERROR("Got 0 Connection names");
+                continue;
+            }
+
+            const std::string& connectionName = connectionNames[0].first;
+
+            sdbusplus::asio::getProperty<std::string>(
+                *crow::connections::systemBus, connectionName, objPath,
+                "xyz.openbmc_project.FruDevice", "BOARD_MANUFACTURE_DATE",
+                [asyncResp](const boost::system::error_code& ec2,
+                            const std::string& value) {
+                if (ec2)
+                {
+                    if (ec2.value() != EBADR)
+                    {
+                        BMCWEB_LOG_ERROR("DBUS response error for Location {}",
+                                         ec2.value());
+                        messages::internalError(asyncResp->res);
+                    }
+                    return;
+                }
+                asyncResp->res.jsonValue["ProductionDate"] = value;
+                });
+            return;
+        }
+        });
+}
+
+inline void getPowerDistributionAsset(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Asset",
+        [asyncResp](const boost::system::error_code& /*ec2*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        const std::string* partNumber = nullptr;
+        const std::string* serialNumber = nullptr;
+        const std::string* manufacturer = nullptr;
+        const std::string* model = nullptr;
+        const std::string* sparePartNumber = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList,
+            "PartNumber", partNumber, "SerialNumber", serialNumber,
+            "Manufacturer", manufacturer, "Model", model,
+            "SparePartNumber", sparePartNumber);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (partNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+        }
+
+        if (serialNumber != nullptr)
+        {
+            asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+        }
+
+        if (manufacturer != nullptr)
+        {
+            asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+        }
+
+        if (model != nullptr)
+        {
+            asyncResp->res.jsonValue["Model"] = *model;
+            asyncResp->res.jsonValue["UserLabel"] = *model;
+            getPowerDistributionProductionDate(asyncResp, *model);
+        }
+
+        // SparePartNumber is optional on D-Bus
+        // so skip if it is empty
+        if (sparePartNumber != nullptr && !sparePartNumber->empty())
+        {
+            asyncResp->res.jsonValue["SparePartNumber"] =
+                *sparePartNumber;
+        }
+        });
+}
+
+inline void getPowerDistributionLocation(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.LocationCode",
+        [asyncResp](const boost::system::error_code& ec,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR("DBUS response error for LocationCode {}",
+                                 ec.value());
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+
+        const size_t* locationOrdinalValue = nullptr;
+        const std::string* locationType = nullptr;
+        const std::string* orientation = nullptr;
+        const std::string* reference = nullptr;
+        const std::string* serviceLabel = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "LocationOrdinalValue",
+            locationOrdinalValue, "LocationType", locationType, "Orientation",
+            orientation, "Reference", reference, "ServiceLabel", serviceLabel);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (locationOrdinalValue != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["LocationOrdinalValue"] =
+                *locationOrdinalValue;
+        }
+        if (locationType != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["LocationType"] =
+                *locationType;
+        }
+        if (orientation != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["Orientation"] =
+                *orientation;
+        }
+        if (reference != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["Reference"] =
+                *reference;
+        }
+        if (serviceLabel != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["ServiceLabel"] =
+                *serviceLabel;
+        }
+        });
+}
+
+inline void getPowerDistributionUniqueIdentifier(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.UniqueIdentifier",
+        "UniqueIdentifier",
+        [path, asyncResp{std::move(asyncResp)}](
+            const boost::system::error_code& ec, const std::string& property) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR("DBUS response error for UniqueIdentifier {}",
+                                 ec.value());
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+        asyncResp->res.jsonValue["UUID"] = property;
+        });
+}
+
+inline void getPowerDistributionHWVersion(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Revision",
+        "Version",
+        [path, asyncResp{std::move(asyncResp)}](
+            const boost::system::error_code& ec, const std::string& property) {
+        if (ec)
+        {
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR("DBUS response error for HWVersion {}",
+                                 ec.value());
+                messages::internalError(asyncResp->res);
+            }
+            return;
+        }
+        asyncResp->res.jsonValue["Version"] = property;
+        });
+}
+
+inline void doPowerDistributionCollection(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId,
+    const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["Name"] = "Power Shelf Configuration";
+    asyncResp->res.jsonValue["Id"] = "PowerShelf";
+    asyncResp->res.jsonValue["Description"] = "Power Shelf Configuration Service";
+    asyncResp->res.jsonValue["EquipmentTye"] = "PowerShelf";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}", powerdistributionId);
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+    asyncResp->res.jsonValue["PowerSupplies"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies",
+                            powerdistributionId);
+    asyncResp->res.jsonValue["Metrics"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics",
+                            powerdistributionId);
+
+    nlohmann::json::array_t chassisAry;
+    nlohmann::json::object_t chassis;
+    chassis["@odata.id"] = "/redfish/v1/Chassis";
+    chassisAry.emplace_back(std::move(chassis));
+    asyncResp->res.jsonValue["Links"]["Chassis"] =
+        std::move(chassisAry);
+
+    nlohmann::json::array_t managedBy;
+    nlohmann::json::object_t manager;
+    manager["@odata.id"] = "/redfish/v1/Managers/bmc";
+    managedBy.emplace_back(std::move(manager));
+    asyncResp->res.jsonValue["Links"]["ManagedBy"] =
+        std::move(managedBy);
+
+    asyncResp->res.jsonValue["Sensors"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/Chassis/{}/Sensors",
+                            powerdistributionId);
+
+    sw_util::populateSoftwareInformation(asyncResp, sw_util::bmcPurpose,
+                                         "FirmwareVersion", false);
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    dbus::utility::getSubTree(
+        "/xyz/openbmc_project/inventory", 0, interfaces,
+        [asyncResp, powerdistributionId(std::string(powerdistributionId))](
+            const boost::system::error_code& ec,
+            const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        // Iterate over all retrieved ObjectPaths.
+        for (const std::pair<
+                 std::string,
+                 std::vector<std::pair<std::string, std::vector<std::string>>>>&
+                 object : subtree)
+        {
+            const std::string& path = object.first;
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object.second;
+
+            sdbusplus::message::object_path objPath(path);
+            if (objPath.filename() != powerdistributionId)
+            {
+                continue;
+            }
+
+            if (connectionNames.empty())
+            {
+                BMCWEB_LOG_ERROR("Got 0 Connection names");
+                continue;
+            }
+
+            const std::string& connectionName = connectionNames[0].first;
+
+            getPowerDistributionAsset(asyncResp, connectionName, path);
+            getPowerDistributionLocation(asyncResp, connectionName, path);
+            getPowerDistributionUniqueIdentifier(asyncResp, connectionName, path);
+            getPowerDistributionHWVersion(asyncResp, connectionName, path);
+
+            return;
+        }
+        });
+}
+
+inline void handlePowerDistributionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionCollection, asyncResp, powerdistributionId));
+}
+
+inline void
+    getPowerDistributionMetricsReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                       const std::string& chassisId,
+                                       const std::string& sensorPath,
+                                       const std::string& id,
+                                       const std::string& location)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        sensorPath, interfaces,
+        [asyncResp, chassisId, sensorPath, id, location]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, sensorPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR("DBUS response error for Reading {}", ec2.value());
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value)
+            {
+                asyncResp->res.jsonValue[location]["DataSourceUri"] = boost::urls::format(
+                    "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                asyncResp->res.jsonValue[location]["Reading"] = std::to_string(value);
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerDistributionMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                       const std::string& powerdistributionId,
+                                       const std::string& sensorPath)
+{
+    sdbusplus::message::object_path path(sensorPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty())
+    {
+        return;
+    }
+
+    std::string escaped(powerdistributionId);
+    escaped.replace(escaped.begin(), escaped.end()-1, "PD");
+    const std::string& pdId = std::move(escaped);
+
+    if (sensorName.find(pdId) == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("Absolute_Humidity") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "AbsoluteHumidity");
+    }
+    else if (sensorName.find("Energy_kWh") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "EnergykWh");
+    }
+    else if (sensorName.find("Humidity_Percent") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "HumidityPercent");
+    }
+    else if (sensorName.find("PowerLoad_Percent") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "PowerLoadPercent");
+    }
+    else if (sensorName.find("Power_Watts") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "PowerWatts");
+    }
+    else if (sensorName.find("Temperature") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "TemperatureCelsius");
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerDistributionMetricsCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& powerdistributionId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistributionMetrics.v1_2_0.PowerDistributionMetrics";
+    asyncResp->res.jsonValue["Name"] = "Summary Metrics";
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics", powerdistributionId);
+
+    std::string sensorPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        sensorPath, [asyncResp, powerdistributionId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR("DBUS response error {}", ec.value());
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerDistributionMetricsList(asyncResp, powerdistributionId, endpoint);
+            }
+        });
+}
+
+inline void handlePowerDistributionMetricsGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionMetricsCollection, asyncResp, powerdistributionId));
+}
+
+/**
+ *  PowerDistributionCollection derived class for delivering PowerDistribution
+ *  Collection Schema Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerDistributionCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerDistributionMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionMetricsGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/power_equipment.hpp b/redfish-core/lib/power_equipment.hpp
new file mode 100644
index 0000000000..baba5474c5
--- /dev/null
+++ b/redfish-core/lib/power_equipment.hpp
@@ -0,0 +1,54 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+namespace redfish
+{
+
+inline void handlePowerEquipmentGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerEquipment.v1_1_0.PowerEquipment";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment";
+    asyncResp->res.jsonValue["Name"] = "Power Equipment Configuration";
+    asyncResp->res.jsonValue["Id"] = "Power Equipment";
+    asyncResp->res.jsonValue["Description"] = "Power Equipment Configuration Service";
+    asyncResp->res.jsonValue["PowerShelves"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment/PowerShelves";
+
+    nlohmann::json::array_t managedBy;
+    nlohmann::json::object_t manager;
+    manager["@odata.id"] = "/redfish/v1/Managers/bmc";
+    managedBy.emplace_back(std::move(manager));
+    asyncResp->res.jsonValue["Links"]["ManagedBy"] =
+        std::move(managedBy);
+}
+
+/**
+ * ChassisCollection derived class for delivering Chassis Collection Schema
+ *  Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerEquipment(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/")
+        .privileges(redfish::privileges::getPowerEquipment)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerEquipmentGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/power_supply.hpp b/redfish-core/lib/power_supply.hpp
index f59ed57d5f..c7d97e6e17 100644
--- a/redfish-core/lib/power_supply.hpp
+++ b/redfish-core/lib/power_supply.hpp
@@ -22,10 +22,12 @@ static constexpr std::array<std::string_view, 1> powerSupplyInterface = {
     "xyz.openbmc_project.Inventory.Item.PowerSupply"};
 
 inline void updatePowerSupplyList(
+    const crow::Request& req,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
     const std::string& chassisId,
     const dbus::utility::MapperGetSubTreePathsResponse& powerSupplyPaths)
 {
+    size_t found = req.url().encoded_path().find("PowerEquipment");
     nlohmann::json& powerSupplyList = asyncResp->res.jsonValue["Members"];
     for (const std::string& powerSupplyPath : powerSupplyPaths)
     {
@@ -37,9 +39,18 @@ inline void updatePowerSupplyList(
         }
 
         nlohmann::json item = nlohmann::json::object();
-        item["@odata.id"] = boost::urls::format(
-            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-            powerSupplyName);
+        if (found == std::string::npos)
+        {
+            item["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+                powerSupplyName);
+        }
+        else
+        {
+            item["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+                powerSupplyName);
+        }
 
         powerSupplyList.emplace_back(std::move(item));
     }
@@ -47,7 +58,8 @@ inline void updatePowerSupplyList(
 }
 
 inline void
-    doPowerSupplyCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyCollection(const crow::Request& req,
+                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                             const std::string& chassisId,
                             const std::optional<std::string>& validChassisPath)
 {
@@ -57,14 +69,31 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     asyncResp->res.addHeader(
         boost::beast::http::field::link,
         "</redfish/v1/JsonSchemas/PowerSupplyCollection/PowerSupplyCollection.json>; rel=describedby");
     asyncResp->res.jsonValue["@odata.type"] =
         "#PowerSupplyCollection.PowerSupplyCollection";
     asyncResp->res.jsonValue["Name"] = "Power Supply Collection";
-    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-        "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies", chassisId);
+    }
+
+    asyncResp->res.jsonValue["Actions"]["#PowerSupply.Reset"]["target"] =
+        boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/Actions/PowerSupply.Reset/",
+        chassisId);
+
     asyncResp->res.jsonValue["Description"] =
         "The collection of PowerSupply resource instances.";
     asyncResp->res.jsonValue["Members"] = nlohmann::json::array();
@@ -75,7 +104,7 @@ inline void
         powerPath,
         sdbusplus::message::object_path("/xyz/openbmc_project/inventory"), 0,
         powerSupplyInterface,
-        [asyncResp, chassisId](
+        [req, asyncResp, chassisId](
             const boost::system::error_code& ec,
             const dbus::utility::MapperGetSubTreePathsResponse& subtreePaths) {
         if (ec)
@@ -88,7 +117,7 @@ inline void
             return;
         }
 
-        updatePowerSupplyList(asyncResp, chassisId, subtreePaths);
+        updatePowerSupplyList(req, asyncResp, chassisId, subtreePaths);
     });
 }
 
@@ -129,7 +158,68 @@ inline void handlePowerSupplyCollectionGet(
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyCollection, asyncResp, chassisId));
+        std::bind_front(doPowerSupplyCollection, req, asyncResp, chassisId));
+}
+
+inline void handlePowerSupplyCollectionResetPost(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& /*chassisId*/)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+    std::optional<std::string> resetType;
+    if (!json_util::readJsonAction(req, asyncResp->res, "ResetType", resetType))
+    {
+        // readJson adds appropriate error to response
+        return;
+    }
+
+    if (!resetType)
+    {
+        messages::actionParameterMissing(asyncResp->res, "PowerSupply.Reset",
+                                         "ResetType");
+        return;
+    }
+
+    // PowerSupply object so far only support On operation for TEST
+    if (resetType != "On")
+    {
+        messages::propertyValueNotInList(asyncResp->res, *resetType,
+                                         "ResetType");
+        return;
+    }
+
+    std::string command = "xyz.openbmc_project.State.Host.Transition.On";
+
+    sdbusplus::asio::setProperty(
+        *crow::connections::systemBus, "xyz.openbmc_project.State.Host",
+        "/xyz/openbmc_project/state/host0",
+        "xyz.openbmc_project.State.Host", "RequestedHostTransition", command,
+        [asyncResp, resetType](const boost::system::error_code& ec) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("D-Bus responses error: {}", ec.value());
+            if (ec.value() == boost::asio::error::invalid_argument)
+            {
+                messages::actionParameterNotSupported(asyncResp->res,
+                                                      *resetType, "Reset");
+                return;
+            }
+
+            if (ec.value() == boost::asio::error::host_unreachable)
+            {
+                messages::resourceNotFound(asyncResp->res, "Actions", "Reset");
+                return;
+            }
+
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        messages::success(asyncResp->res);
+        });
 }
 
 inline void requestRoutesPowerSupplyCollection(App& app)
@@ -143,6 +233,17 @@ inline void requestRoutesPowerSupplyCollection(App& app)
         .privileges(redfish::privileges::getPowerSupplyCollection)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/")
+        .privileges(redfish::privileges::getPowerSupplyCollection)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app,
+        "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/Actions/PowerSupply.Reset/")
+        .privileges(redfish::privileges::postPowerSupplyCollection)
+        .methods(boost::beast::http::verb::post)(
+            std::bind_front(handlePowerSupplyCollectionResetPost, std::ref(app)));
 }
 
 inline bool checkPowerSupplyId(const std::string& powerSupplyPath,
@@ -345,11 +446,11 @@ inline void
     getPowerSupplyLocation(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                            const std::string& service, const std::string& path)
 {
-    sdbusplus::asio::getProperty<std::string>(
+    sdbusplus::asio::getAllProperties(
         *crow::connections::systemBus, service, path,
-        "xyz.openbmc_project.Inventory.Decorator.LocationCode", "LocationCode",
+        "xyz.openbmc_project.Inventory.Decorator.LocationCode",
         [asyncResp](const boost::system::error_code& ec,
-                    const std::string& value) {
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
         if (ec)
         {
             if (ec.value() != EBADR)
@@ -360,96 +461,251 @@ inline void
             }
             return;
         }
-        asyncResp->res.jsonValue["Location"]["PartLocation"]["ServiceLabel"] =
-            value;
+
+        const size_t* locationOrdinalValue = nullptr;
+        const std::string* locationType = nullptr;
+        const std::string* orientation = nullptr;
+        const std::string* reference = nullptr;
+        const std::string* serviceLabel = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList, "LocationOrdinalValue",
+            locationOrdinalValue, "LocationType", locationType, "Orientation",
+            orientation, "Reference", reference, "ServiceLabel", serviceLabel);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (locationOrdinalValue != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["LocationOrdinalValue"] =
+                *locationOrdinalValue;
+        }
+        if (locationType != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["LocationType"] =
+                *locationType;
+        }
+        if (orientation != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["Orientation"] =
+                *orientation;
+        }
+        if (reference != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["Reference"] =
+                *reference;
+        }
+        if (serviceLabel != nullptr)
+        {
+            asyncResp->res.jsonValue["Location"]["PartLocation"]["ServiceLabel"] =
+                *serviceLabel;
+        }
     });
 }
 
-inline void handleGetEfficiencyResponse(
-    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-    const boost::system::error_code& ec, uint32_t value)
+inline void
+    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& powerSupplyPath)
 {
-    if (ec)
-    {
-        if (ec.value() != EBADR)
+    static const std::string efficiencyIntf =
+        "xyz.openbmc_project.Inventory.Decorator.EfficiencyRatings";
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, powerSupplyPath]
+        (const boost::system::error_code ec,
+         const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
         {
-            BMCWEB_LOG_ERROR("DBUS response error for DeratingFactor {}",
-                             ec.value());
-            messages::internalError(asyncResp->res);
+            if (ec.value() != EBADR)
+            {
+                BMCWEB_LOG_ERROR("DBUS response error for EfficiencyPercent {}",
+                                 ec.value());
+                messages::internalError(asyncResp->res);
+            }
+            return;
         }
-        return;
-    }
-    // The PDI default value is 0, if it hasn't been set leave off
-    if (value == 0)
-    {
-        return;
-    }
 
-    nlohmann::json::array_t efficiencyRatings;
-    nlohmann::json::object_t efficiencyPercent;
-    efficiencyPercent["EfficiencyPercent"] = value;
-    efficiencyRatings.emplace_back(std::move(efficiencyPercent));
-    asyncResp->res.jsonValue["EfficiencyRatings"] =
-        std::move(efficiencyRatings);
+        for (const auto& [path, serviceMap] : subtree)
+        {
+            for (const auto& [service, interfaces] : serviceMap)
+            {
+                if (powerSupplyPath != path)
+                {
+                    continue;
+                }
+
+                sdbusplus::asio::getAllProperties(
+                    *crow::connections::systemBus, service, path,
+                    efficiencyIntf,
+                    [asyncResp](const boost::system::error_code ec2,
+                                const dbus::utility::DBusPropertiesMap& propertiesList) {
+                    if (ec2)
+                    {
+                        if (ec2.value() != EBADR)
+                        {
+                            messages::internalError(asyncResp->res);
+                        }
+                        return;
+                    }
+
+                    const double* effiPH = nullptr;
+                    const double* effiPM = nullptr;
+                    const double* effiPL = nullptr;
+                    const double* loadPH = nullptr;
+                    const double* loadPM = nullptr;
+                    const double* loadPL = nullptr;
+
+                    const bool success = sdbusplus::unpackPropertiesNoThrow(
+                        dbus_utils::UnpackErrorPrinter(), propertiesList, "EfficiencyPercentHigh",
+                        effiPH, "EfficiencyPercentMedium", effiPM, "EfficiencyPercentLow",
+                        effiPL, "LoadPercentHigh", loadPH, "LoadPercentMedium", loadPM,
+                        "LoadPercentLow", loadPL);
+
+                    if (!success)
+                    {
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    nlohmann::json item;
+                    nlohmann::json& efficiencyList =
+                        asyncResp->res.jsonValue["EfficiencyRatings"];
+                    if (effiPH != nullptr && loadPH != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPH;
+                        item["LoadPercent"] = *loadPH;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPM != nullptr && loadPM != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPM;
+                        item["LoadPercent"] = *loadPM;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPL != nullptr && loadPL != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPL;
+                        item["LoadPercent"] = *loadPL;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+                    });
+            }
+        }
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+        "/xyz/openbmc_project", 0,
+        std::array<const char*, 1>{efficiencyIntf.c_str()});
 }
 
-inline void handlePowerSupplyAttributesSubTreeResponse(
-    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-    const boost::system::error_code& ec,
-    const dbus::utility::MapperGetSubTreeResponse& subtree)
+inline void
+    getPowerSupplyReplaceable(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                              const std::string& service, const std::string& path)
 {
-    if (ec)
-    {
-        if (ec.value() != EBADR)
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Replaceable",
+        [asyncResp](const boost::system::error_code& /*ec*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        const bool* replaceable = nullptr;
+        const bool* hotpluggable = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList,
+            "FieldReplaceable", replaceable,
+            "HotPluggable", hotpluggable);
+
+        if (!success)
         {
-            BMCWEB_LOG_ERROR("DBUS response error for EfficiencyPercent {}",
-                             ec.value());
             messages::internalError(asyncResp->res);
+            return;
         }
-        return;
-    }
 
-    if (subtree.empty())
-    {
-        BMCWEB_LOG_DEBUG("Can't find Power Supply Attributes!");
-        return;
-    }
-
-    if (subtree.size() != 1)
-    {
-        BMCWEB_LOG_ERROR(
-            "Unexpected number of paths returned by getSubTree: {}",
-            subtree.size());
-        messages::internalError(asyncResp->res);
-        return;
-    }
+        if (replaceable != nullptr)
+        {
+            asyncResp->res.jsonValue["Replaceable"] = *replaceable;
+        }
 
-    const auto& [path, serviceMap] = *subtree.begin();
-    const auto& [service, interfaces] = *serviceMap.begin();
-    sdbusplus::asio::getProperty<uint32_t>(
-        *crow::connections::systemBus, service, path,
-        "xyz.openbmc_project.Control.PowerSupplyAttributes", "DeratingFactor",
-        [asyncResp](const boost::system::error_code& ec1, uint32_t value) {
-        handleGetEfficiencyResponse(asyncResp, ec1, value);
+        if (hotpluggable != nullptr)
+        {
+            asyncResp->res.jsonValue["HotPluggable"] = *hotpluggable;
+        }
     });
 }
 
 inline void
-    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+    getPowerSupplyVendorInformation(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                    const std::string& service, const std::string& path)
 {
-    constexpr std::array<std::string_view, 1> efficiencyIntf = {
-        "xyz.openbmc_project.Control.PowerSupplyAttributes"};
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.VendorInformation",
+        [asyncResp](const boost::system::error_code& /*ec*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        const std::string* inputNominalVoltage = nullptr;
+        const std::string* outputNominalVoltage = nullptr;
+        const std::string* phaseWiringType = nullptr;
+        const std::string* plugType = nullptr;
+        const std::string* powerSupplyType = nullptr;
+        const std::string* version = nullptr;
 
-    dbus::utility::getSubTree(
-        "/xyz/openbmc_project", 0, efficiencyIntf,
-        [asyncResp](const boost::system::error_code& ec,
-                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
-        handlePowerSupplyAttributesSubTreeResponse(asyncResp, ec, subtree);
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList,
+            "InputNominalVoltageType", inputNominalVoltage,
+            "OutputNominalVoltageType", outputNominalVoltage,
+            "PhaseWiringType", phaseWiringType,
+            "PlugType", plugType,
+            "PowerSupplyType", powerSupplyType,
+            "Version", version);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (inputNominalVoltage != nullptr)
+        {
+            asyncResp->res.jsonValue["InputNominalVoltageType"] = *inputNominalVoltage;
+        }
+
+        if (outputNominalVoltage != nullptr)
+        {
+            asyncResp->res.jsonValue["OutputNominalVoltageType"] = *outputNominalVoltage;
+        }
+
+        if (phaseWiringType != nullptr)
+        {
+            asyncResp->res.jsonValue["PhaseWiringType"] = *phaseWiringType;
+        }
+
+        if (plugType != nullptr)
+        {
+            asyncResp->res.jsonValue["PlugType"] = *plugType;
+        }
+
+        if (powerSupplyType != nullptr)
+        {
+            asyncResp->res.jsonValue["PowerSupplyType"] = *powerSupplyType;
+        }
+
+        if (version != nullptr)
+        {
+            /* Should be from PMBUS */
+            asyncResp->res.jsonValue["Version"] = *version;
+        }
     });
 }
 
 inline void
-    doPowerSupplyGet(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                      const std::string& chassisId,
                      const std::string& powerSupplyId,
                      const std::optional<std::string>& validChassisPath)
@@ -460,9 +716,11 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     // Get the correct Path and Service that match the input parameters
     getValidPowerSupplyPath(asyncResp, *validChassisPath, powerSupplyId,
-                            [asyncResp, chassisId, powerSupplyId](
+                            [asyncResp, chassisId, powerSupplyId, found](
                                 const std::string& powerSupplyPath) {
         asyncResp->res.addHeader(
             boost::beast::http::field::link,
@@ -471,9 +729,32 @@ inline void
             "#PowerSupply.v1_5_0.PowerSupply";
         asyncResp->res.jsonValue["Name"] = "Power Supply";
         asyncResp->res.jsonValue["Id"] = powerSupplyId;
-        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-            powerSupplyId);
+
+        if (found == std::string::npos)
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+                chassisId, powerSupplyId);
+        }
+        else
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+                chassisId, powerSupplyId);
+        }
+
+        nlohmann::json::array_t chassisAry;
+        nlohmann::json::object_t chassis;
+        chassis["@odata.id"] = "/redfish/v1/Chassis";
+        chassisAry.emplace_back(std::move(chassis));
+        asyncResp->res.jsonValue["Links"]["PoweringChassis"] =
+            std::move(chassisAry);
 
         asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
         asyncResp->res.jsonValue["Status"]["Health"] = "OK";
@@ -499,9 +780,13 @@ inline void
                                           powerSupplyPath);
             getPowerSupplyLocation(asyncResp, object.begin()->first,
                                    powerSupplyPath);
+            getPowerSupplyReplaceable(asyncResp, object.begin()->first,
+                                      powerSupplyPath);
+            getPowerSupplyVendorInformation(asyncResp, object.begin()->first,
+                                            powerSupplyPath);
         });
 
-        getEfficiencyPercent(asyncResp);
+        getEfficiencyPercent(asyncResp, powerSupplyPath);
     });
 }
 
@@ -549,7 +834,7 @@ inline void
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyGet, asyncResp, chassisId, powerSupplyId));
+        std::bind_front(doPowerSupplyGet, req, asyncResp, chassisId, powerSupplyId));
 }
 
 inline void requestRoutesPowerSupply(App& app)
@@ -565,6 +850,12 @@ inline void requestRoutesPowerSupply(App& app)
         .privileges(redfish::privileges::getPowerSupply)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyGet, std::ref(app)));
+
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/")
+        .privileges(redfish::privileges::getPowerSupply)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyGet, std::ref(app)));
 }
 
 } // namespace redfish
diff --git a/redfish-core/lib/power_supply_metrics.hpp b/redfish-core/lib/power_supply_metrics.hpp
new file mode 100644
index 0000000000..9b4933b155
--- /dev/null
+++ b/redfish-core/lib/power_supply_metrics.hpp
@@ -0,0 +1,261 @@
+#pragma once
+
+#include "app.hpp"
+#include "dbus_utility.hpp"
+#include "query.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/chassis_utils.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/url/format.hpp>
+
+#include <memory>
+#include <optional>
+#include <string>
+
+namespace redfish
+{
+
+inline void
+    getPowerSupplyReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& chassisId,
+                          const std::string& powerSupplyPath,
+                          const std::string& id,
+                          const std::string& location,
+                          bool isArray)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        powerSupplyPath, interfaces,
+        [asyncResp, chassisId, powerSupplyPath, id, location, isArray]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, powerSupplyPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location, isArray]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR("DBUS response error for Reading {}", ec2.value());
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value >= 0)
+            {
+                if (isArray)
+                {
+                    nlohmann::json::object_t item;
+                    item["DataSourceUri"] = boost::urls::format(
+                        "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+
+                    if ( location == "FanSpeedPercent" ) {
+                        item["SpeedRPM"] = std::to_string(value);
+                    }
+                    else
+                        item["Reading"] = std::to_string(value);
+
+                    nlohmann::json& sensorList = asyncResp->res.jsonValue[location];
+                    sensorList.emplace_back(std::move(item));
+                }
+                else
+                {
+                    asyncResp->res.jsonValue[location]["DataSourceUri"] = boost::urls::format(
+                        "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                    asyncResp->res.jsonValue[location]["Reading"] = std::to_string(value);
+                }
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerSupplyMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                 const std::string& chassisId,
+                                 const std::string& powerSupplyId,
+                                 const std::string& powerSupplyPath)
+{
+    sdbusplus::message::object_path path(powerSupplyPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty())
+    {
+        return;
+    }
+
+    std::string escaped(powerSupplyId);
+    escaped.replace(escaped.begin(), escaped.end()-1, "PSU");
+    const std::string& psuId = std::move(escaped);
+
+    if (sensorName.find(psuId) == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("Energy_kWh") != std::string::npos)
+     {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "EnergykWh", false);
+    }
+    else if (sensorName.find("Fan_Speed") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["FanSpeedPercent"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "FanSpeedPercent", true);
+    }
+    else if (sensorName.find("Frequency_Hz") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "FrequencyHz", false);
+    }
+    else if (sensorName.find("Input_Current") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputCurrentAmps", false);
+    }
+    else if (sensorName.find("Input_Power") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputPowerWatts", false);
+    }
+    else if (sensorName.find("Input_Voltage") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputVoltage", false);
+    }
+    else if (sensorName.find("Output_Current") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailCurrentAmps"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailCurrentAmps", true);
+    }
+    else if (sensorName.find("Output_Power") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailPowerWatts"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailPowerWatts", true);
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "OutputPowerWatts", false);
+    }
+    else if (sensorName.find("Output_Voltage") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailVoltage"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailVoltage", true);
+    }
+    else if (sensorName.find("Temperature") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "TemperatureCelsius", false);
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerSupplyMetricsGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& chassisId,
+                     const std::string& powerSupplyId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", chassisId);
+        return;
+    }
+
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerSupplyMetrics.v1_0_0.PowerSupplyMetrics";
+    asyncResp->res.jsonValue["Name"] = powerSupplyId;
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+
+    std::string powerPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        powerPath, [asyncResp, chassisId, powerSupplyId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR("DBUS response error {}", ec.value());
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerSupplyMetricsList(asyncResp, chassisId, powerSupplyId, endpoint);
+            }
+        });
+}
+
+inline void
+    handlePowerSupplyMetricsCollectionGet(App& app, const crow::Request& req,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& chassisId,
+                         const std::string& powerSupplyId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, chassisId,
+        std::bind_front(doPowerSupplyMetricsGet, req, asyncResp, chassisId, powerSupplyId));
+}
+
+inline void requestRoutesPowerSupplyMetricsCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/PowerSubsystem/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/service_root.hpp b/redfish-core/lib/service_root.hpp
index 2fc35150dd..a4d9cd887f 100644
--- a/redfish-core/lib/service_root.hpp
+++ b/redfish-core/lib/service_root.hpp
@@ -87,6 +87,8 @@ inline void handleServiceRootGetImpl(
     asyncResp->res.jsonValue["TelemetryService"]["@odata.id"] =
         "/redfish/v1/TelemetryService";
     asyncResp->res.jsonValue["Cables"]["@odata.id"] = "/redfish/v1/Cables";
+    asyncResp->res.jsonValue["PowerEquipment"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment";
 
     asyncResp->res.jsonValue["Links"]["ManagerProvidingService"]["@odata.id"] =
         "/redfish/v1/Managers/bmc";
diff --git a/redfish-core/src/redfish.cpp b/redfish-core/src/redfish.cpp
index 47d6fc2d07..ae4485417a 100644
--- a/redfish-core/src/redfish.cpp
+++ b/redfish-core/src/redfish.cpp
@@ -26,8 +26,11 @@
 #include "network_protocol.hpp"
 #include "pcie.hpp"
 #include "power.hpp"
+#include "power_distribution.hpp"
+#include "power_equipment.hpp"
 #include "power_subsystem.hpp"
 #include "power_supply.hpp"
+#include "power_supply_metrics.hpp"
 #include "processor.hpp"
 #include "redfish_sessions.hpp"
 #include "redfish_v1.hpp"
@@ -71,9 +74,12 @@ RedfishService::RedfishService(App& app)
     if constexpr (BMCWEB_REDFISH_NEW_POWERSUBSYSTEM_THERMALSUBSYSTEM)
     {
         requestRoutesEnvironmentMetrics(app);
+        requestRoutesPowerDistributionCollection(app);
+        requestRoutesPowerEquipment(app);
         requestRoutesPowerSubsystem(app);
         requestRoutesPowerSupply(app);
         requestRoutesPowerSupplyCollection(app);
+        requestRoutesPowerSupplyMetricsCollection(app);
         requestRoutesThermalMetrics(app);
         requestRoutesThermalSubsystem(app);
         requestRoutesFan(app);
-- 
2.34.1


From 9381abfdbf016a1a74367cc64abb88670c850f0a Mon Sep 17 00:00:00 2001
From: Ban Feng <kcfeng0@nuvoton.com>
Date: Wed, 5 Jul 2023 09:24:04 +0800
Subject: [PATCH] Implement Power{Equipment, Distribution, Supply,
 SupplyMetrics} schema

Signed-off-by: Ban Feng <kcfeng0@nuvoton.com>
Signed-off-by: Allen Kang <jhkang@nuvoton.com>
---
 redfish-core/include/redfish.hpp          |   6 +
 redfish-core/lib/power_distribution.hpp   | 336 ++++++++++++++++++++++
 redfish-core/lib/power_equipment.hpp      |  47 +++
 redfish-core/lib/power_supply.hpp         | 222 ++++++++++++--
 redfish-core/lib/power_supply_metrics.hpp | 251 ++++++++++++++++
 redfish-core/lib/service_root.hpp         |   2 +
 6 files changed, 840 insertions(+), 24 deletions(-)
 create mode 100644 redfish-core/lib/power_distribution.hpp
 create mode 100644 redfish-core/lib/power_equipment.hpp
 create mode 100644 redfish-core/lib/power_supply_metrics.hpp

diff --git a/redfish-core/include/redfish.hpp b/redfish-core/include/redfish.hpp
index e97a83286..7583276a6 100644
--- a/redfish-core/include/redfish.hpp
+++ b/redfish-core/include/redfish.hpp
@@ -38,8 +38,11 @@
 #include "pcie.hpp"
 #include "pcie_slots.hpp"
 #include "power.hpp"
+#include "power_distribution.hpp"
+#include "power_equipment.hpp"
 #include "power_subsystem.hpp"
 #include "power_supply.hpp"
+#include "power_supply_metrics.hpp"
 #include "processor.hpp"
 #include "redfish_sessions.hpp"
 #include "redfish_v1.hpp"
@@ -91,9 +94,12 @@ class RedfishService
 #endif
 #ifdef BMCWEB_NEW_POWERSUBSYSTEM_THERMALSUBSYSTEM
         requestRoutesEnvironmentMetrics(app);
+        requestRoutesPowerDistributionCollection(app);
+        requestRoutesPowerEquipment(app);
         requestRoutesPowerSubsystem(app);
         requestRoutesPowerSupply(app);
         requestRoutesPowerSupplyCollection(app);
+        requestRoutesPowerSupplyMetricsCollection(app);
         requestRoutesThermalSubsystem(app);
 #endif
         requestRoutesManagerCollection(app);
diff --git a/redfish-core/lib/power_distribution.hpp b/redfish-core/lib/power_distribution.hpp
new file mode 100644
index 000000000..a9022f285
--- /dev/null
+++ b/redfish-core/lib/power_distribution.hpp
@@ -0,0 +1,336 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/chassis_utils.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+#include "utils/sw_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <boost/url/format.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+#include <array>
+#include <string_view>
+
+namespace redfish
+{
+
+inline void handlePowerDistributionCollectionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment/PowerShelves";
+    asyncResp->res.jsonValue["Name"] = "PowerEquipment PowerShelves Collection";
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    collection_util::getCollectionMembers(
+        asyncResp, boost::urls::url("/redfish/v1/PowerEquipment/PowerShelves"), interfaces);
+}
+
+inline void doPowerDistributionCollection(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId,
+    const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistribution.v1_1_0.PowerDistribution";
+    asyncResp->res.jsonValue["Name"] = "Power Shelf Configuration";
+    asyncResp->res.jsonValue["Id"] = "PowerShelf";
+    asyncResp->res.jsonValue["Description"] = "Power Shelf Configuration Service";
+    asyncResp->res.jsonValue["EquipmentTye"] = "PowerShelf";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}", powerdistributionId);
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+    asyncResp->res.jsonValue["PowerSupplies"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies",
+                            powerdistributionId);
+    asyncResp->res.jsonValue["Metrics"]["@odata.id"] =
+        boost::urls::format("/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics",
+                            powerdistributionId);
+
+    sw_util::populateSoftwareInformation(asyncResp, sw_util::bmcPurpose,
+                                         "FirmwareVersion", false);
+
+    constexpr std::array<std::string_view, 2> interfaces{
+        "xyz.openbmc_project.Inventory.Item.Board",
+        "xyz.openbmc_project.Inventory.Item.Chassis"};
+    dbus::utility::getSubTree(
+        "/xyz/openbmc_project/inventory", 0, interfaces,
+        [asyncResp, powerdistributionId(std::string(powerdistributionId))](
+            const boost::system::error_code& ec,
+            const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        // Iterate over all retrieved ObjectPaths.
+        for (const std::pair<
+                 std::string,
+                 std::vector<std::pair<std::string, std::vector<std::string>>>>&
+                 object : subtree)
+        {
+            const std::string& path = object.first;
+            const std::vector<std::pair<std::string, std::vector<std::string>>>&
+                connectionNames = object.second;
+
+            sdbusplus::message::object_path objPath(path);
+            if (objPath.filename() != powerdistributionId)
+            {
+                continue;
+            }
+
+            if (connectionNames.empty())
+            {
+                BMCWEB_LOG_ERROR << "Got 0 Connection names";
+                continue;
+            }
+
+            const std::string& connectionName = connectionNames[0].first;
+
+            sdbusplus::asio::getAllProperties(
+                *crow::connections::systemBus, connectionName, path,
+                "xyz.openbmc_project.Inventory.Decorator.Asset",
+                [asyncResp, powerdistributionId(std::string(powerdistributionId))](
+                    const boost::system::error_code& /*ec2*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+                const std::string* partNumber = nullptr;
+                const std::string* serialNumber = nullptr;
+                const std::string* manufacturer = nullptr;
+                const std::string* model = nullptr;
+                const std::string* sparePartNumber = nullptr;
+
+                const bool success = sdbusplus::unpackPropertiesNoThrow(
+                    dbus_utils::UnpackErrorPrinter(), propertiesList,
+                    "PartNumber", partNumber, "SerialNumber", serialNumber,
+                    "Manufacturer", manufacturer, "Model", model,
+                    "SparePartNumber", sparePartNumber);
+
+                if (!success)
+                {
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                if (partNumber != nullptr)
+                {
+                    asyncResp->res.jsonValue["PartNumber"] = *partNumber;
+                }
+
+                if (serialNumber != nullptr)
+                {
+                    asyncResp->res.jsonValue["SerialNumber"] = *serialNumber;
+                }
+
+                if (manufacturer != nullptr)
+                {
+                    asyncResp->res.jsonValue["Manufacturer"] = *manufacturer;
+                }
+
+                if (model != nullptr)
+                {
+                    asyncResp->res.jsonValue["Model"] = *model;
+                }
+
+                // SparePartNumber is optional on D-Bus
+                // so skip if it is empty
+                if (sparePartNumber != nullptr && !sparePartNumber->empty())
+                {
+                    asyncResp->res.jsonValue["SparePartNumber"] =
+                        *sparePartNumber;
+                }
+                });
+
+            return;
+        }
+        });
+}
+
+inline void handlePowerDistributionGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionCollection, asyncResp, powerdistributionId));
+}
+
+inline void
+    getPowerDistributionMetricsReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                       const std::string& chassisId,
+                                       const std::string& sensorPath,
+                                       const std::string& id,
+                                       const std::string& location)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        sensorPath, interfaces,
+        [asyncResp, chassisId, sensorPath, id, location]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, sensorPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error for DeratingFactor";
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value)
+            {
+                asyncResp->res.jsonValue[location]["DataSourceUri"] = boost::urls::format(
+                    "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                asyncResp->res.jsonValue[location]["Reading"] = std::to_string(value);
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerDistributionMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                       const std::string& powerdistributionId,
+                                       const std::string& sensorPath)
+{
+    sdbusplus::message::object_path path(sensorPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty() || sensorName.find("Temp") == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("BUV") != std::string::npos)
+    {
+        getPowerDistributionMetricsReading(asyncResp, powerdistributionId, sensorPath,
+                                           id, "TemperatureCelsius");
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerDistributionMetricsCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& powerdistributionId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", powerdistributionId);
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerDistributionMetrics.v1_2_0.PowerDistributionMetrics";
+    asyncResp->res.jsonValue["Name"] = "Summary Metrics";
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+        "/redfish/v1/PowerEquipment/PowerShelves/{}/Metrics", powerdistributionId);
+
+    std::string sensorPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        sensorPath, [asyncResp, powerdistributionId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error" << ec.value();
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerDistributionMetricsList(asyncResp, powerdistributionId, endpoint);
+            }
+        });
+}
+
+inline void handlePowerDistributionMetricsGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& powerdistributionId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, powerdistributionId,
+        std::bind_front(doPowerDistributionMetricsCollection, asyncResp, powerdistributionId));
+}
+
+/**
+ *  PowerDistributionCollection derived class for delivering PowerDistribution
+ *  Collection Schema Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerDistributionCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/")
+        .privileges(redfish::privileges::getPowerDistribution)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerDistributionMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerDistributionMetricsGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/power_equipment.hpp b/redfish-core/lib/power_equipment.hpp
new file mode 100644
index 000000000..d81423d02
--- /dev/null
+++ b/redfish-core/lib/power_equipment.hpp
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "app.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/collection.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/system/error_code.hpp>
+#include <sdbusplus/asio/property.hpp>
+#include <sdbusplus/unpack_properties.hpp>
+
+namespace redfish
+{
+
+inline void handlePowerEquipmentGet(
+    App& app, const crow::Request& req,
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerEquipment.v1_1_0.PowerEquipment";
+    asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/PowerEquipment";
+    asyncResp->res.jsonValue["Name"] = "Power Equipment Configuration";
+    asyncResp->res.jsonValue["Id"] = "Power Equipment";
+    asyncResp->res.jsonValue["Description"] = "Power Equipment Configuration Service";
+    asyncResp->res.jsonValue["PowerShelves"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment/PowerShelves";
+}
+
+/**
+ * ChassisCollection derived class for delivering Chassis Collection Schema
+ *  Functions triggers appropriate requests on DBus
+ */
+inline void requestRoutesPowerEquipment(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/")
+        .privileges(redfish::privileges::getPowerEquipment)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerEquipmentGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/power_supply.hpp b/redfish-core/lib/power_supply.hpp
index 09f731b54..cd95d4516 100644
--- a/redfish-core/lib/power_supply.hpp
+++ b/redfish-core/lib/power_supply.hpp
@@ -22,10 +22,12 @@ static constexpr std::array<std::string_view, 1> powerSupplyInterface = {
     "xyz.openbmc_project.Inventory.Item.PowerSupply"};
 
 inline void updatePowerSupplyList(
+    const crow::Request& req,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
     const std::string& chassisId,
     const dbus::utility::MapperGetSubTreePathsResponse& powerSupplyPaths)
 {
+    size_t found = req.url().encoded_path().find("PowerEquipment");
     nlohmann::json& powerSupplyList = asyncResp->res.jsonValue["Members"];
     for (const std::string& powerSupplyPath : powerSupplyPaths)
     {
@@ -37,9 +39,18 @@ inline void updatePowerSupplyList(
         }
 
         nlohmann::json item = nlohmann::json::object();
-        item["@odata.id"] = boost::urls::format(
-            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-            powerSupplyName);
+        if (found == std::string::npos)
+        {
+            item["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+                powerSupplyName);
+        }
+        else
+        {
+            item["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+                powerSupplyName);
+        }
 
         powerSupplyList.emplace_back(std::move(item));
     }
@@ -47,7 +58,8 @@ inline void updatePowerSupplyList(
 }
 
 inline void
-    doPowerSupplyCollection(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyCollection(const crow::Request& req,
+                            const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                             const std::string& chassisId,
                             const std::optional<std::string>& validChassisPath)
 {
@@ -57,14 +69,26 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     asyncResp->res.addHeader(
         boost::beast::http::field::link,
         "</redfish/v1/JsonSchemas/PowerSupplyCollection/PowerSupplyCollection.json>; rel=describedby");
     asyncResp->res.jsonValue["@odata.type"] =
         "#PowerSupplyCollection.PowerSupplyCollection";
     asyncResp->res.jsonValue["Name"] = "Power Supply Collection";
-    asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-        "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies", chassisId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies", chassisId);
+    }
+
     asyncResp->res.jsonValue["Description"] =
         "The collection of PowerSupply resource instances.";
     asyncResp->res.jsonValue["Members"] = nlohmann::json::array();
@@ -75,7 +99,7 @@ inline void
         powerPath,
         sdbusplus::message::object_path("/xyz/openbmc_project/inventory"), 0,
         powerSupplyInterface,
-        [asyncResp, chassisId](
+        [req, asyncResp, chassisId](
             const boost::system::error_code& ec,
             const dbus::utility::MapperGetSubTreePathsResponse& subtreePaths) {
         if (ec)
@@ -88,7 +112,7 @@ inline void
             return;
         }
 
-        updatePowerSupplyList(asyncResp, chassisId, subtreePaths);
+        updatePowerSupplyList(req, asyncResp, chassisId, subtreePaths);
         });
 }
 
@@ -129,7 +153,7 @@ inline void handlePowerSupplyCollectionGet(
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyCollection, asyncResp, chassisId));
+        std::bind_front(doPowerSupplyCollection, req, asyncResp, chassisId));
 }
 
 inline void requestRoutesPowerSupplyCollection(App& app)
@@ -143,6 +167,11 @@ inline void requestRoutesPowerSupplyCollection(App& app)
         .privileges(redfish::privileges::getPowerSupplyCollection)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/")
+        .privileges(redfish::privileges::getPowerSupplyCollection)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyCollectionGet, std::ref(app)));
 }
 
 inline bool checkPowerSupplyId(const std::string& powerSupplyPath,
@@ -435,21 +464,140 @@ inline void handlePowerSupplyAttributesSubTreeResponse(
 }
 
 inline void
-    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
+    getEfficiencyPercent(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& powerSupplyPath)
 {
-    constexpr std::array<std::string_view, 1> efficiencyIntf = {
-        "xyz.openbmc_project.Control.PowerSupplyAttributes"};
+    static const std::string efficiencyIntf =
+        "xyz.openbmc_project.Inventory.Decorator.EfficiencyRatings";
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, powerSupplyPath]
+        (const boost::system::error_code ec,
+         const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec)
+        {
+            if (ec.value() == EBADR)
+            {
+                return;
+            }
+            BMCWEB_LOG_ERROR << "respHandler DBus error " << ec.message();
+            messages::internalError(asyncResp->res);
+            return;
+        }
 
-    dbus::utility::getSubTree(
-        "/xyz/openbmc_project", 0, efficiencyIntf,
-        [asyncResp](const boost::system::error_code& ec,
-                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
-        handlePowerSupplyAttributesSubTreeResponse(asyncResp, ec, subtree);
+        for (const auto& [path, serviceMap] : subtree)
+        {
+            for (const auto& [service, interfaces] : serviceMap)
+            {
+                if (powerSupplyPath != path)
+                {
+                    continue;
+                }
+
+                sdbusplus::asio::getAllProperties(
+                    *crow::connections::systemBus, service, path,
+                    efficiencyIntf,
+                    [asyncResp](const boost::system::error_code ec2,
+                                const dbus::utility::DBusPropertiesMap& propertiesList) {
+                    if (ec2)
+                    {
+                        if (ec2.value() != EBADR)
+                        {
+                            messages::internalError(asyncResp->res);
+                        }
+                        return;
+                    }
+
+                    const double* effiPH = nullptr;
+                    const double* effiPM = nullptr;
+                    const double* effiPL = nullptr;
+                    const double* loadPH = nullptr;
+                    const double* loadPM = nullptr;
+                    const double* loadPL = nullptr;
+
+                    const bool success = sdbusplus::unpackPropertiesNoThrow(
+                        dbus_utils::UnpackErrorPrinter(), propertiesList, "EfficiencyPercentHigh",
+                        effiPH, "EfficiencyPercentMedium", effiPM, "EfficiencyPercentLow",
+                        effiPL, "LoadPercentHigh", loadPH, "LoadPercentMedium", loadPM,
+                        "LoadPercentLow", loadPL);
+
+                    if (!success)
+                    {
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    nlohmann::json item;
+                    nlohmann::json& efficiencyList =
+                        asyncResp->res.jsonValue["EfficiencyRatings"];
+                    if (effiPH != nullptr && loadPH != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPH;
+                        item["LoadPercent"] = *loadPH;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPM != nullptr && loadPM != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPM;
+                        item["LoadPercent"] = *loadPM;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+
+                    if (effiPL != nullptr && loadPL != nullptr)
+                    {
+                        item["EfficiencyPercent"] = *effiPL;
+                        item["LoadPercent"] = *loadPL;
+                        efficiencyList.emplace_back(std::move(item));
+                    }
+                    });
+            }
+        }
+        },
+        "xyz.openbmc_project.ObjectMapper",
+        "/xyz/openbmc_project/object_mapper",
+        "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+        "/xyz/openbmc_project", 0,
+        std::array<const char*, 1>{efficiencyIntf.c_str()});
+}
+
+inline void
+    getPowerSupplyReplaceable(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                              const std::string& service, const std::string& path)
+{
+    sdbusplus::asio::getAllProperties(
+        *crow::connections::systemBus, service, path,
+        "xyz.openbmc_project.Inventory.Decorator.Replaceable",
+        [asyncResp](const boost::system::error_code& /*ec*/,
+                    const dbus::utility::DBusPropertiesMap& propertiesList) {
+        const bool* replaceable = nullptr;
+        const bool* hotpluggable = nullptr;
+
+        const bool success = sdbusplus::unpackPropertiesNoThrow(
+            dbus_utils::UnpackErrorPrinter(), propertiesList,
+            "FieldReplaceable", replaceable,
+            "HotPluggable", hotpluggable);
+
+        if (!success)
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        if (replaceable != nullptr)
+        {
+            asyncResp->res.jsonValue["Replaceable"] = *replaceable;
+        }
+
+        if (hotpluggable != nullptr)
+        {
+            asyncResp->res.jsonValue["HotPluggable"] = *hotpluggable;
+        }
         });
 }
 
 inline void
-    doPowerSupplyGet(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    doPowerSupplyGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                      const std::string& chassisId,
                      const std::string& powerSupplyId,
                      const std::optional<std::string>& validChassisPath)
@@ -460,9 +608,11 @@ inline void
         return;
     }
 
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
     // Get the correct Path and Service that match the input parameters
     getValidPowerSupplyPath(asyncResp, *validChassisPath, powerSupplyId,
-                            [asyncResp, chassisId, powerSupplyId](
+                            [asyncResp, chassisId, powerSupplyId, found](
                                 const std::string& powerSupplyPath) {
         asyncResp->res.addHeader(
             boost::beast::http::field::link,
@@ -471,9 +621,25 @@ inline void
             "#PowerSupply.v1_5_0.PowerSupply";
         asyncResp->res.jsonValue["Name"] = "Power Supply";
         asyncResp->res.jsonValue["Id"] = powerSupplyId;
-        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
-            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
-            powerSupplyId);
+
+        if (found == std::string::npos)
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] = boost::urls::format(
+                "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+                chassisId, powerSupplyId);
+        }
+        else
+        {
+            asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}", chassisId,
+                powerSupplyId);
+            asyncResp->res.jsonValue["Metrics"]["@odata.id"] = boost::urls::format(
+                "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+                chassisId, powerSupplyId);
+        }
 
         asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
         asyncResp->res.jsonValue["Status"]["Health"] = "OK";
@@ -499,9 +665,11 @@ inline void
                                           powerSupplyPath);
             getPowerSupplyLocation(asyncResp, object.begin()->first,
                                    powerSupplyPath);
+            getPowerSupplyReplaceable(asyncResp, object.begin()->first,
+                                      powerSupplyPath);
             });
 
-        getEfficiencyPercent(asyncResp);
+        getEfficiencyPercent(asyncResp, powerSupplyPath);
     });
 }
 
@@ -549,7 +717,7 @@ inline void
 
     redfish::chassis_utils::getValidChassisPath(
         asyncResp, chassisId,
-        std::bind_front(doPowerSupplyGet, asyncResp, chassisId, powerSupplyId));
+        std::bind_front(doPowerSupplyGet, req, asyncResp, chassisId, powerSupplyId));
 }
 
 inline void requestRoutesPowerSupply(App& app)
@@ -565,6 +733,12 @@ inline void requestRoutesPowerSupply(App& app)
         .privileges(redfish::privileges::getPowerSupply)
         .methods(boost::beast::http::verb::get)(
             std::bind_front(handlePowerSupplyGet, std::ref(app)));
+
+    BMCWEB_ROUTE(
+        app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/")
+        .privileges(redfish::privileges::getPowerSupply)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyGet, std::ref(app)));
 }
 
 } // namespace redfish
diff --git a/redfish-core/lib/power_supply_metrics.hpp b/redfish-core/lib/power_supply_metrics.hpp
new file mode 100644
index 000000000..95b2f40db
--- /dev/null
+++ b/redfish-core/lib/power_supply_metrics.hpp
@@ -0,0 +1,251 @@
+#pragma once
+
+#include "app.hpp"
+#include "dbus_utility.hpp"
+#include "query.hpp"
+#include "registries/privilege_registry.hpp"
+#include "utils/chassis_utils.hpp"
+#include "utils/dbus_utils.hpp"
+#include "utils/json_utils.hpp"
+
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/url/format.hpp>
+
+#include <memory>
+#include <optional>
+#include <string>
+
+namespace redfish
+{
+
+inline void
+    getPowerSupplyReading(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& chassisId,
+                          const std::string& powerSupplyPath,
+                          const std::string& id,
+                          const std::string& location,
+                          bool isArray)
+{
+    constexpr std::array<std::string_view, 1> interfaces = {
+        "xyz.openbmc_project.Sensor.Value"};
+    dbus::utility::getDbusObject(
+        powerSupplyPath, interfaces,
+        [asyncResp, chassisId, powerSupplyPath, id, location, isArray]
+        (const boost::system::error_code& ec,
+         const dbus::utility::MapperGetObject& object) {
+        if (ec || object.empty())
+        {
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        sdbusplus::asio::getProperty<double>(
+            *crow::connections::systemBus, object.begin()->first, powerSupplyPath,
+            "xyz.openbmc_project.Sensor.Value", "Value",
+            [asyncResp, chassisId, id, location, isArray]
+            (const boost::system::error_code& ec2, const double value) {
+            if (ec2)
+            {
+                if (ec2.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error for DeratingFactor";
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            if (value >= 0)
+            {
+                if (isArray)
+                {
+                    nlohmann::json::object_t item;
+                    item["DataSourceUri"] = boost::urls::format(
+                        "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+
+                    if ( location == "FanSpeedPercent" ) {
+                        item["SpeedRPM"] = std::to_string(value);
+                    }
+                    else
+                        item["Reading"] = std::to_string(value);
+
+                    nlohmann::json& sensorList = asyncResp->res.jsonValue[location];
+                    sensorList.emplace_back(std::move(item));
+                }
+                else
+                {
+                    asyncResp->res.jsonValue[location]["DataSourceUri"] = boost::urls::format(
+                        "/redfish/v1/Chassis/{}/Sensors/{}", chassisId, id);
+                    asyncResp->res.jsonValue[location]["Reading"] = std::to_string(value);
+                }
+            }
+            });
+        });
+}
+
+inline void
+    updatePowerSupplyMetricsList(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                                 const std::string& chassisId,
+                                 const std::string& powerSupplyId,
+                                 const std::string& powerSupplyPath)
+{
+    sdbusplus::message::object_path path(powerSupplyPath);
+    std::string sensorName = path.filename();
+    if (sensorName.empty())
+    {
+        return;
+    }
+
+    const std::string& psuId =
+        boost::replace_all_copy(powerSupplyId, "powersupply", "PSU");
+
+    if (sensorName.find(psuId) == std::string::npos)
+    {
+        return;
+    }
+
+    std::string type = path.parent_path().filename();
+    type.erase(std::remove(type.begin(), type.end(), '_'), type.end());
+    std::string id = type;
+    id += "_";
+    id += sensorName;
+
+    if (sensorName.find("Input_Current") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputCurrentAmps", false);
+    }
+    else if (sensorName.find("Input_Power") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputPowerWatts", false);
+    }
+    else if (sensorName.find("Input_Voltage") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "InputVoltage", false);
+    }
+    else if (sensorName.find("Output_Current") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailCurrentAmps"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailCurrentAmps", true);
+    }
+    else if (sensorName.find("Output_Power") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailPowerWatts"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailPowerWatts", true);
+    }
+    else if (sensorName.find("Output_Voltage") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["RailVoltage"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "RailVoltage", true);
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "OutputPowerWatts", false);
+    }
+    else if (sensorName.find("Temperature") != std::string::npos)
+    {
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "TemperatureCelsius", false);
+    }
+    else if (sensorName.find("Fan_Speed") != std::string::npos)
+    {
+        asyncResp->res.jsonValue["FanSpeedPercent"] = nlohmann::json::array();
+        getPowerSupplyReading(asyncResp, chassisId, powerSupplyPath,
+                              id, "FanSpeedPercent", true);
+    }
+    else
+    {
+        return;
+    }
+}
+
+inline void
+    doPowerSupplyMetricsGet(const crow::Request& req,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                     const std::string& chassisId,
+                     const std::string& powerSupplyId,
+                     const std::optional<std::string>& validChassisPath)
+{
+    if (!validChassisPath)
+    {
+        messages::resourceNotFound(asyncResp->res, "Chassis", chassisId);
+        return;
+    }
+
+    size_t found = req.url().encoded_path().find("PowerEquipment");
+
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#PowerSupplyMetrics.v1_0_0.PowerSupplyMetrics";
+    asyncResp->res.jsonValue["Name"] = powerSupplyId;
+    asyncResp->res.jsonValue["Id"] = "Metrics";
+
+    if (found == std::string::npos)
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/Chassis/{}/PowerSubsystem/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+    else
+    {
+        asyncResp->res.jsonValue["@odata.id"] = boost::urls::format(
+            "/redfish/v1/PowerEquipment/PowerShelves/{}/PowerSupplies/{}/Metrics",
+            chassisId, powerSupplyId);
+    }
+
+    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+    asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+
+    std::string powerPath = *validChassisPath + "/all_sensors";
+    dbus::utility::getAssociationEndPoints(
+        powerPath, [asyncResp, chassisId, powerSupplyId](
+                       const boost::system::error_code& ec,
+                       const dbus::utility::MapperEndPoints& endpoints) {
+            if (ec)
+            {
+                if (ec.value() != EBADR)
+                {
+                    BMCWEB_LOG_ERROR << "DBUS response error" << ec.value();
+                    messages::internalError(asyncResp->res);
+                }
+                return;
+            }
+
+            for (const auto& endpoint : endpoints)
+            {
+                updatePowerSupplyMetricsList(asyncResp, chassisId, powerSupplyId, endpoint);
+            }
+        });
+}
+
+inline void
+    handlePowerSupplyMetricsCollectionGet(App& app, const crow::Request& req,
+                         const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                         const std::string& chassisId,
+                         const std::string& powerSupplyId)
+{
+    if (!redfish::setUpRedfishRoute(app, req, asyncResp))
+    {
+        return;
+    }
+
+    redfish::chassis_utils::getValidChassisPath(
+        asyncResp, chassisId,
+        std::bind_front(doPowerSupplyMetricsGet, req, asyncResp, chassisId, powerSupplyId));
+}
+
+inline void requestRoutesPowerSupplyMetricsCollection(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/Chassis/<str>/PowerSubsystem/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+
+    BMCWEB_ROUTE(app, "/redfish/v1/PowerEquipment/PowerShelves/<str>/PowerSupplies/<str>/Metrics")
+        .privileges(redfish::privileges::getPowerSupplyMetrics)
+        .methods(boost::beast::http::verb::get)(
+            std::bind_front(handlePowerSupplyMetricsCollectionGet, std::ref(app)));
+}
+
+} // namespace redfish
diff --git a/redfish-core/lib/service_root.hpp b/redfish-core/lib/service_root.hpp
index 6ae16c378..b9578e47f 100644
--- a/redfish-core/lib/service_root.hpp
+++ b/redfish-core/lib/service_root.hpp
@@ -86,6 +86,8 @@ inline void handleServiceRootGetImpl(
     asyncResp->res.jsonValue["TelemetryService"]["@odata.id"] =
         "/redfish/v1/TelemetryService";
     asyncResp->res.jsonValue["Cables"]["@odata.id"] = "/redfish/v1/Cables";
+    asyncResp->res.jsonValue["PowerEquipment"]["@odata.id"] =
+        "/redfish/v1/PowerEquipment";
 
     asyncResp->res.jsonValue["Links"]["ManagerProvidingService"]["@odata.id"] =
         "/redfish/v1/Managers/bmc";
-- 
2.34.1


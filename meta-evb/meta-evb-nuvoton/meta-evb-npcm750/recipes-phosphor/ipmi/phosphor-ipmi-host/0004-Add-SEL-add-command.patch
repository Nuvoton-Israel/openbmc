diff --git a/dbus-sdr/storagecommands.cpp b/dbus-sdr/storagecommands.cpp
index 4910aae..8f1577e 100644
--- a/dbus-sdr/storagecommands.cpp
+++ b/dbus-sdr/storagecommands.cpp
@@ -1080,6 +1080,67 @@ ipmi::RspType<uint16_t, // Next Record ID
     return ipmi::responseUnspecifiedError();
 }
 
+#if 0
+static void toHexStr(const std::span<uint8_t> bytes, std::string& hexStr)
+{
+    std::stringstream stream;
+    stream << std::hex << std::uppercase << std::setfill('0');
+    for (const uint8_t& byte : bytes)
+    {
+        stream << std::setw(2) << static_cast<int>(byte);
+    }
+    hexStr = stream.str();
+}
+
+static inline bool defaultMessageHook(uint16_t recordID, uint8_t recordType,
+                                      uint32_t timestamp, uint16_t generatorID,
+                                      uint8_t evmRev, uint8_t sensorType,
+                                      uint8_t sensorNum, uint8_t eventType,
+                                      std::array<uint8_t, 3> eventData)
+{
+    // Log the record as a default Redfish message instead of a SEL record
+
+    // Save the raw IPMI string of the request
+    std::string ipmiRaw;
+    std::array selBytes = {static_cast<uint8_t>(recordID),
+                           static_cast<uint8_t>(recordID >> 8),
+                           recordType,
+                           static_cast<uint8_t>(timestamp),
+                           static_cast<uint8_t>(timestamp >> 8),
+                           static_cast<uint8_t>(timestamp >> 16),
+                           static_cast<uint8_t>(timestamp >> 24),
+                           static_cast<uint8_t>(generatorID),
+                           static_cast<uint8_t>(generatorID >> 8),
+                           evmRev,
+                           sensorType,
+                           sensorNum,
+                           eventType,
+                           eventData[0],
+                           eventData[1],
+                           eventData[2]};
+
+    toHexStr(std::span<uint8_t>(selBytes), ipmiRaw);
+
+    static const std::string openBMCMessageRegistryVersion("0.1");
+    std::string messageID =
+        "OpenBMC." + openBMCMessageRegistryVersion + ".SELEntryAdded";
+
+    std::vector<std::string> messageArgs;
+    messageArgs.push_back(ipmiRaw);
+
+    // Log the Redfish message to the journal with the appropriate metadata
+    std::string journalMsg = "SEL Entry Added: " + ipmiRaw;
+    std::string messageArgsString = boost::algorithm::join(messageArgs, ",");
+    phosphor::logging::log<phosphor::logging::level::INFO>(
+        journalMsg.c_str(),
+        phosphor::logging::entry("REDFISH_MESSAGE_ID=%s", messageID.c_str()),
+        phosphor::logging::entry("REDFISH_MESSAGE_ARGS=%s",
+                                 messageArgsString.c_str()));
+
+    return true;
+}
+#endif
+
 ipmi::RspType<uint16_t> ipmiStorageAddSELEntry(
     uint16_t recordID, uint8_t recordType, uint32_t timestamp,
     uint16_t generatorID, uint8_t evmRev, uint8_t sensorType, uint8_t sensorNum,
@@ -1089,9 +1150,77 @@ ipmi::RspType<uint16_t> ipmiStorageAddSELEntry(
     // Per the IPMI spec, need to cancel any reservation when a SEL entry is
     // added
     cancelSELReservation();
+#if 0
+    // Send this request to the Redfish hooks to log it as a Redfish message
+    // instead.  There is no need to add it to the SEL, so just return success.
+    defaultMessageHook(recordID, recordType, timestamp, generatorID, evmRev,
+                       sensorType, sensorNum, eventType, eventData);
+#endif
+    static constexpr char const* ipmiSELObject =
+        "xyz.openbmc_project.Logging.IPMI";
+    static constexpr char const* ipmiSELPath =
+        "/xyz/openbmc_project/Logging/IPMI";
+    static constexpr char const* ipmiSELAddInterface =
+        "xyz.openbmc_project.Logging.IPMI";
+    static const std::string ipmiSELAddMessage =
+        "IPMI SEL entry logged using IPMI Add SEL Entry command.";
+
+    sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
+    std::vector<uint8_t> eventData = {eventData1, eventData1, eventData2};
+
+    if (recordType == dynamic_sensors::ipmi::sel::systemEvent)
+    {
+        std::string sensorPath = getPathFromSensorNumber(sensorNum);
+
+        if (sensorPath.length() == 0)
+        {
+            return ipmi::responseSensorInvalid();
+        }
+
+        bool assert =
+            (eventType & ipmi::storage::deassertionEvent) ? false : true;
+        uint16_t genId = generatorID;
+        sdbusplus::message::message writeSEL = bus.new_method_call(
+            ipmiSELObject, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAdd");
+        writeSEL.append(ipmiSELAddMessage, sensorPath, eventData, assert,
+                        genId);
+        try
+        {
+            sdbusplus::message::message writeSELResp = bus.call(writeSEL);
+            writeSELResp.read(recordID);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (recordType >= dynamic_sensors::ipmi::sel::oemTsEventFirst &&
+             recordType <= dynamic_sensors::ipmi::sel::oemEventLast)
+    {
+        sdbusplus::message::message writeSEL = bus.new_method_call(
+            ipmiSELObject, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAddOem");
+        writeSEL.append(ipmiSELAddMessage, eventData, recordType);
+        try
+        {
+            sdbusplus::message::message writeSELResp = bus.call(writeSEL);
+            writeSELResp.read(recordID);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess(recordID);
 
-    uint16_t responseID = 0xFFFF;
-    return ipmi::responseSuccess(responseID);
+    // uint16_t responseID = 0xFFFF;
+    // return ipmi::responseSuccess(responseID);
 }
 
 ipmi::RspType<uint8_t> ipmiStorageClearSEL(ipmi::Context::ptr ctx,

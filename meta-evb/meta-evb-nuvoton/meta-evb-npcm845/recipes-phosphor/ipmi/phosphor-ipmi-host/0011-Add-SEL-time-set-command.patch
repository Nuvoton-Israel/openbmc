diff --git a/dbus-sdr/storagecommands.cpp b/dbus-sdr/storagecommands.cpp
index 8f1577e..07e504b 100644
--- a/dbus-sdr/storagecommands.cpp
+++ b/dbus-sdr/storagecommands.cpp
@@ -28,6 +28,7 @@
 #include <ipmid/api.hpp>
 #include <ipmid/message.hpp>
 #include <ipmid/types.hpp>
+#include <ipmid/utils.hpp>
 #include <phosphor-logging/log.hpp>
 #include <sdbusplus/message/types.hpp>
 #include <sdbusplus/timer.hpp>
@@ -108,6 +109,15 @@ constexpr static const char* chassisTypeMainServer = "17";
 // event direction is bit[7] of eventType where 1b = Deassertion event
 constexpr static const uint8_t deassertionEvent = 0x80;
 
+constexpr auto TIME_INTERFACE = "xyz.openbmc_project.Time.EpochTime";
+constexpr auto BMC_TIME_PATH = "/xyz/openbmc_project/time/bmc";
+constexpr auto PROPERTY_ELAPSED = "Elapsed";
+constexpr auto TIME_SYNC_INTERFACE = "xyz.openbmc_project.Time.Synchronization";
+constexpr auto TIME_SYNC_PATH = "/xyz/openbmc_project/time/sync_method";
+constexpr auto TIME_SYNC_PROPERTIE = "TimeSyncMethod";
+constexpr auto TIME_SYNC_MANUAL =
+    "xyz.openbmc_project.Time.Synchronization.Method.Manual";
+
 static std::vector<uint8_t> fruCache;
 static uint8_t cacheBus = 0xFF;
 static uint8_t cacheAddr = 0XFF;
@@ -1300,10 +1310,50 @@ ipmi::RspType<uint32_t> ipmiStorageGetSELTime()
     return ipmi::responseSuccess(selTime.tv_sec);
 }
 
-ipmi::RspType<> ipmiStorageSetSELTime(uint32_t selTime)
+ipmi::RspType<> ipmiStorageSetSELTime(ipmi::Context::ptr ctx, uint32_t selTime)
 {
-    // Set SEL Time is not supported
-    return ipmi::responseInvalidCommand();
+    using namespace std::chrono;
+    using namespace phosphor::logging;
+    microseconds usec{seconds(selTime)};
+
+    std::string service;
+    boost::system::error_code ec;
+    // Force set time sync method to manual first
+    ec = ipmi::getService(ctx, TIME_SYNC_INTERFACE, TIME_SYNC_PATH, service);
+    if (ec)
+    {
+        log<level::ERR>("Cannot get time sync service",
+                        entry("WHAT=%s", ec.message().c_str()));
+        return ipmi::responseUnspecifiedError();
+    }
+    ec = ipmi::setDbusProperty(ctx, service, TIME_SYNC_PATH,
+                               TIME_SYNC_INTERFACE, TIME_SYNC_PROPERTIE,
+                               std::string(TIME_SYNC_MANUAL));
+    if (ec)
+    {
+        log<level::ERR>("Cannot set time sync mode to manual",
+                        entry("WHAT=%s", ec.message().c_str()));
+        return ipmi::responseUnspecifiedError();
+    }
+    // Set bmc time
+    ec = ipmi::getService(ctx, TIME_INTERFACE, BMC_TIME_PATH, service);
+    if (ec)
+    {
+        log<level::ERR>("Cannot get time manager service",
+                        entry("WHAT=%s", ec.message().c_str()));
+        return ipmi::responseUnspecifiedError();
+    }
+    ec = ipmi::setDbusProperty(ctx, service, BMC_TIME_PATH, TIME_INTERFACE,
+                               PROPERTY_ELAPSED, (uint64_t)usec.count());
+    if (ec)
+    {
+        log<level::ERR>("Cannot set time, ", entry("value=%ul", usec.count()),
+                        entry("service=%s", service.c_str()),
+                        entry("WHAT=%s", ec.message().c_str()));
+        return ipmi::responseUnspecifiedError();
+    }
+
+    return ipmi::responseSuccess();
 }
 
 std::vector<uint8_t> getType12SDRs(uint16_t index, uint16_t recordId)
